# Вопросы
1.  **Модуль в иерархии программных систем:**
    * Независимо компилируемый и динамически загружаемый/выгружаемый блок кода, расширяющий функциональность ядра ОС (например, драйверы, файловые системы). Работает в привилегированном режиме ядра.

2.  **Программирование в ядре. Создание среды разработки:**
    * Программирование ведется в основном на C.
    * Среда требует: компилятор (GCC), заголовочные файлы используемой версии ядра (`kernel-headers`/`kernel-devel`), систему сборки (`make`). Часто разработка ведется на одной машине, а отладка/тестирование — на другой (или виртуальной).

3.  **Специфика программирования в ядре:**
    * Нет стандартной библиотеки C (libc) и защиты памяти.
    * Ограниченный размер стека.
    * Ручное управление памятью (kmalloc/kfree и т.д.).
    * Необходимость обработки прерываний и конкурентного доступа (блокировки).
    * Прямой доступ к аппаратуре.
    * Ошибки фатальны (могут вызвать панику ядра).
    * Нежелательно использовать операции с плавающей точкой.

4.  **Компиляция (сборка) модуля. Сборка сложных модулей:**
    * Используется система сборки ядра (Kbuild) через `Makefile`.
    * Простой `Makefile` содержит `obj-m += my_module.o`.
    * Для сложных модулей указываются все исходные файлы (`my_module-objs := file1.o file2.o`) и сам модуль (`obj-m += my_module.o`).
    * Команда сборки: `make -C /path/to/kernel/source M=$(pwd) modules`.

5.  **Тестирование модуля. Загрузка и исполнение:**
    * Загрузка: `insmod ./my_module.ko` (прямой путь) или `modprobe my_module` (поиск в стандартных местах + зависимости).
    * Исполнение: Код модуля выполняется в контексте ядра при вызове его функций (например, при обращении к устройству, которое он обслуживает).
    * Выгрузка: `rmmod my_module`.
    * Тестирование: Загрузка, проверка функциональности, анализ логов (`dmesg`), выгрузка. Обычно на тестовой системе/ВМ.

6.  **Точки входа и завершения. Внутренний формат модуля:**
    * Точка входа: Функция, зарегистрированная макросом `module_init()`. Вызывается при загрузке (`insmod`/`modprobe`).
    * Точка завершения: Функция, зарегистрированная макросом `module_exit()`. Вызывается при выгрузке (`rmmod`).
    * Внутренний формат: ELF-файл (обычно с расширением `.ko`), содержащий код, данные, таблицу символов и метаинформацию (лицензия, автор, зависимости и т.д.).

7.  **Вывод диагностики модуля. Основные ошибки модуля:**
    * Диагностика: Функция `printk()` с указанием уровня (например, `KERN_INFO`, `KERN_ERR`). Вывод попадает в системный журнал (кольцевой буфер ядра), просматривается командой `dmesg`.
    * Основные ошибки: Разыменование NULL-указателей, ошибки управления памятью (утечки, use-after-free), состояние гонки (race conditions), взаимоблокировки (deadlocks), неверное использование API ядра, паника ядра.

8.  **Варианты загрузки модулей. Полезные примеры модулей:**
    * Варианты загрузки: Вручную (`insmod`, `modprobe`), автоматически при старте системы (через конфигурационные файлы, например, в `/etc/modules-load.d/`), по требованию (udev при обнаружении оборудования).
    * Примеры: Драйверы устройств (USB, сеть, графика), файловые системы (ext4, xfs, ntfs), сетевые фильтры (iptables/nftables), криптографические модули, модули для мониторинга и отладки.
Здравствуйте! Давайте разберем эти вопросы по сетевому программированию в контексте Linux.

**9. Сетевое программирование (теория)**

Сетевое программирование — это процесс написания программ, которые обмениваются данными с другими программами через компьютерную сеть. В Linux, как и в других Unix-подобных системах, основным инструментом для этого является API сокетов (Berkeley Sockets API).

Основные концепции:
* **Модель Клиент-Сервер:** Наиболее распространенная модель, где одна программа (сервер) ожидает входящих подключений и запросов от других программ (клиентов). Клиент инициирует соединение и запрашивает данные или услуги.
* **Сокеты (Sockets):** Это конечные точки для обмена данными между процессами по сети. Представляют собой абстракцию, позволяющую приложению подключаться к сети и обмениваться данными, не вникая в детали работы сетевых протоколов нижних уровней. В Linux сокеты представлены как файловые дескрипторы.
* **Протоколы:** Набор правил, определяющих формат и порядок обмена данными. Ключевые протоколы транспортного уровня – TCP и UDP.
    * **TCP (Transmission Control Protocol):** Гарантирует доставку данных в правильном порядке, устанавливает соединение перед обменом данными (connection-oriented). Используется для задач, где важна надежность (веб-страницы, почта, передача файлов).
    * **UDP (User Datagram Protocol):** Не гарантирует доставку и порядок пакетов, не устанавливает предварительное соединение (connectionless). Используется там, где важнее скорость или допустимы потери (стриминг видео/аудио, DNS, онлайн-игры).
* **IP-адреса и Порты:** Для идентификации компьютера в сети используется IP-адрес. Для идентификации конкретного приложения (сервиса) на этом компьютере используется номер порта (целое число от 0 до 65535). Комбинация IP-адреса и порта однозначно определяет конечную точку сетевого соединения.
* **Порядок байтов (Byte Order):** Компьютеры могут хранить многобайтовые числа по-разному (Big-endian или Little-endian). Сетевой порядок байтов стандартизирован как Big-endian. Функции `htons()`, `htonl()`, `ntohs()`, `ntohl()` используются для преобразования между порядком байтов хоста и сетевым порядком.

**10. Общий алгоритм программирования сокетов**

Алгоритм зависит от того, создаете ли вы сервер или клиент, и какой протокол используется (TCP или UDP). Рассмотрим наиболее частый случай - TCP клиент-сервер:

**Сервер (TCP):**
1.  **Создание сокета (`socket()`):** Создается конечная точка для коммуникации. Указывается домен (например, `AF_INET` для IPv4), тип (`SOCK_STREAM` для TCP) и протокол (обычно 0, чтобы система выбрала подходящий). Возвращает файловый дескриптор сокета.
    ```c
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    ```
2.  **Связывание сокета с адресом и портом (`bind()`):** Сокету присваивается локальный IP-адрес и номер порта, на котором он будет ожидать входящие соединения. Это необходимо, чтобы клиенты знали, куда подключаться.
    ```c
    struct sockaddr_in address;
    // ... (заполнение структуры address: family, IP-адрес, порт) ...
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    ```
    *Часто используется `INADDR_ANY` для IP-адреса, чтобы принимать соединения на любом сетевом интерфейсе.*
3.  **Перевод сокета в режим прослушивания (`listen()`):** Сервер указывает ядру, что готов принимать входящие соединения на этом сокете. Устанавливается максимальная длина очереди ожидающих соединений.
    ```c
    listen(server_fd, SOMAXCONN); // SOMAXCONN - стандартная константа для размера очереди
    ```
4.  **Принятие входящего соединения (`accept()`):** Сервер блокируется (по умолчанию) до тех пор, пока не поступит запрос на соединение от клиента. Когда соединение установлено, `accept()` создает *новый* сокет (новый файловый дескриптор), предназначенный для обмена данными *только с этим конкретным клиентом*. Исходный (слушающий) сокет остается открытым для приема других соединений.
    ```c
    int new_socket_fd = accept(server_fd, (struct sockaddr *)&client_address, &addrlen);
    ```
5.  **Передача данных (`read()`/`recv()`, `write()`/`send()`):** Обмен информацией с клиентом происходит через новый сокет (`new_socket_fd`), используя стандартные функции чтения/записи или их аналоги для сокетов.
6.  **Завершение сеанса связи (`close()`):** Когда обмен данными с конкретным клиентом завершен, сокет соединения (`new_socket_fd`) закрывается функцией `close()`. Когда сервер решает прекратить работу, он закрывает и слушающий сокет (`server_fd`).

**Клиент (TCP):**
1.  **Создание сокета (`socket()`):** Аналогично серверу, создается сокет (`AF_INET`, `SOCK_STREAM`).
    ```c
    int sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    ```
2.  **Установление связи с удаленным компьютером (`connect()`):** Клиент пытается установить соединение с сервером, указывая его IP-адрес и порт. Функция блокируется до установления соединения или возникновения ошибки.
    ```c
    struct sockaddr_in serv_addr;
    // ... (заполнение структуры serv_addr: family, IP-адрес сервера, порт сервера) ...
    connect(sock_fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    ```
3.  **Передача данных (`write()`/`send()`, `read()`/`recv()`):** Клиент отправляет запросы серверу и получает ответы, используя созданный и подключенный сокет (`sock_fd`).
4.  **Завершение сеанса связи (`close()`):** Когда обмен данными завершен, клиент закрывает свой сокет.

**Для UDP:** Шаги `listen()`, `accept()`, `connect()` отсутствуют в явном виде (хотя `connect()` *можно* использовать для UDP, чтобы зафиксировать удаленный адрес). Вместо `read`/`write` или `recv`/`send` используются `recvfrom()` и `sendto()`, которые позволяют указать/получить адрес отправителя/получателя для каждой датаграммы. Сервер обычно просто создает сокет, связывает его с портом (`bind()`) и входит в цикл `recvfrom()`, а клиент создает сокет и использует `sendto()` для отправки данных на адрес сервера.

**11. Программирование сокетов (практика): создание приложений клиент/сервер.**

На практике это включает написание кода, реализующего шаги из пункта 10. Важные аспекты:
* **Обработка ошибок:** Каждый системный вызов (`socket`, `bind`, `listen`, `accept`, `connect`, `read`, `write`, `send`, `recv`, etc.) может завершиться ошибкой. Необходимо проверять возвращаемые значения и использовать `perror()` или `strerror(errno)` для диагностики.
* **Обработка множественных клиентов (сервер):** Серверы обычно должны обслуживать несколько клиентов одновременно. Основные подходы в Linux:
    * **Форкинг (`fork()`):** Для каждого нового клиента создается дочерний процесс, который обрабатывает соединение. Просто, но ресурсоемко.
    * **Потоки (`pthreads`):** Для каждого нового клиента создается поток в рамках одного процесса. Менее ресурсоемко, чем форкинг, но требует синхронизации доступа к общим данным.
    * **Мультиплексирование ввода/вывода (`select()`, `poll()`, `epoll()`):** Один процесс/поток отслеживает состояние множества сокетов и обрабатывает те, которые готовы к чтению/записи. `epoll()` является наиболее эффективным и масштабируемым методом в Linux. Используется в сочетании с неблокирующими сокетами (см. п. 16).
* **Формат данных:** Клиент и сервер должны договориться о формате передаваемых данных (протокол прикладного уровня). Это может быть простой текстовый протокол, бинарный формат, JSON, XML и т.д.
* **Очистка ресурсов:** Важно всегда закрывать сокеты (`close()`), когда они больше не нужны, чтобы освободить системные ресурсы.

**12. Программа-сервер.**

Программа-сервер — это приложение, которое:
* Работает в фоновом режиме (часто как демон - daemon).
* Привязывается (`bind`) к известному порту на локальной машине.
* Переходит в режим ожидания (`listen`) входящих подключений.
* Принимает (`accept`) подключения от клиентов.
* Обрабатывает запросы клиентов (читает данные, выполняет действия, отправляет ответ).
* Часто спроектирована для одновременной работы с множеством клиентов (используя форкинг, потоки или мультиплексирование).
* Должна быть надежной и устойчивой к ошибкам.

**13. Программа-клиент.**

Программа-клиент — это приложение, которое:
* Инициирует соединение с сервером, зная его IP-адрес и порт.
* Использует системный вызов `connect()` (для TCP) или `sendto()` (для UDP) для установления связи.
* Отправляет запросы серверу (`write`/`send`/`sendto`).
* Получает ответы от сервера (`read`/`recv`/`recvfrom`).
* Обычно выполняется по запросу пользователя или другого события и завершается после выполнения своей задачи.

**14. Параметры сокета.**

Параметры (опции) сокета позволяют настраивать его поведение. Управление осуществляется с помощью системных вызовов `getsockopt()` (получить значение опции) и `setsockopt()` (установить значение опции).

```c
int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

* `sockfd`: Файловый дескриптор сокета.
* `level`: Уровень, на котором действует опция (например, `SOL_SOCKET` - общие опции сокета, `IPPROTO_TCP` - опции уровня TCP, `IPPROTO_IP` - опции уровня IP).
* `optname`: Имя конкретной опции (например, `SO_REUSEADDR`, `SO_KEEPALIVE`, `TCP_NODELAY`).
* `optval`: Указатель на буфер для значения опции.
* `optlen`: Размер буфера `optval`.

Некоторые важные опции:
* `SO_REUSEADDR` (`SOL_SOCKET`): Позволяет серверу быстро перезапуститься и снова использовать тот же адрес и порт, даже если предыдущие соединения еще находятся в состоянии `TIME_WAIT`. Очень часто используется на серверах.
* `SO_KEEPALIVE` (`SOL_SOCKET`): Включает механизм проверки активности соединения на уровне TCP. Периодически отправляются "пустые" пакеты, чтобы убедиться, что удаленная сторона все еще доступна.
* `TCP_NODELAY` (`IPPROTO_TCP`): Отключает алгоритм Нейгла (Nagle's algorithm), который пытается группировать мелкие пакеты для отправки. Полезно для приложений, требующих низкой задержки (например, интерактивные игры), но может увеличить нагрузку на сеть.
* `SO_RCVBUF` / `SO_SNDBUF` (`SOL_SOCKET`): Управляют размерами буферов приема и передачи сокета в ядре.
* `SO_RCVTIMEO` / `SO_SNDTIMEO` (`SOL_SOCKET`): Устанавливают тайм-ауты для блокирующих операций чтения и записи.

**15. Сигналы, связанные с сокетами.**

Некоторые сигналы могут влиять на работу с сокетами или генерироваться в результате сетевых событий:
* **`SIGPIPE`**: Самый важный сигнал в контексте сокетов. Генерируется, когда процесс пытается записать (`write`/`send`) данные в сокет (или пайп), соединение по которому уже разорвано удаленной стороной. По умолчанию этот сигнал завершает процесс. Обычная практика – игнорировать (`signal(SIGPIPE, SIG_IGN);`) или обрабатывать этот сигнал, а ошибку разрыва соединения определять по коду возврата `EPIPE` из системного вызова `write`/`send`.
* **`SIGURG`**: Генерируется при поступлении "срочных" (out-of-band) данных на сокет. Используется редко.
* **`SIGIO`**: Генерируется, когда на сокете, для которого включен асинхронный ввод/вывод (с помощью `fcntl` с флагами `F_SETOWN` и `O_ASYNC`), происходит событие (например, появились данные для чтения). Используется как альтернатива `select`/`poll`/`epoll`, но менее гибок.
* **`SIGALRM`**: Может использоваться для реализации тайм-аутов на операции с сокетами вручную с помощью функции `alarm()`.

**16. Неблокирующие операции.**

По умолчанию операции с сокетами (`connect`, `accept`, `read`/`recv`, `write`/`send`) являются *блокирующими*. Это значит, что если операция не может быть выполнена немедленно (например, `read` вызывается, а данных еще нет; `accept` вызывается, а клиентов нет; `write` вызывается, а буфер передачи переполнен), то процесс или поток приостанавливает свое выполнение до тех пор, пока операция не станет возможной.

*Неблокирующий режим* позволяет избежать этого ожидания. Сокет переводится в неблокирующий режим с помощью `fcntl`:
```c
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
```
Когда сокет находится в неблокирующем режиме:
* Если операция может быть выполнена немедленно (данные есть, место в буфере есть, клиент подключился), она выполняется как обычно.
* Если операция не может быть выполнена немедленно, она не блокирует процесс, а сразу же возвращает управление с кодом ошибки `EAGAIN` или `EWOULDBLOCK` (в Linux это обычно одно и то же значение).

Неблокирующие операции критически важны при использовании мультиплексирования ввода/вывода (`select`/`poll`/`epoll`). Вы сначала используете мультиплексор, чтобы узнать, какие сокеты готовы к чтению или записи, а затем выполняете соответствующие неблокирующие операции `read`/`write` на этих сокетах, будучи уверенными, что они не заблокируются (или, по крайней мере, обработают часть данных). Это позволяет одному потоку эффективно управлять множеством соединений.

**17. TCP, UDP сокеты.**

Это два основных типа сокетов, соответствующих транспортным протоколам TCP и UDP.

**TCP сокеты (`SOCK_STREAM`):**
* **Тип:** `SOCK_STREAM` (потоковый) при вызове `socket()`.
* **Надежность:** Гарантированная доставка данных без потерь, дублирования и с сохранением порядка. Протокол сам обрабатывает подтверждения, повторные передачи и упорядочивание.
* **Соединение:** Требуется установление соединения (`connect()`, `accept()`) перед обменом данными. Это трехэтапное рукопожатие (three-way handshake).
* **Потоковость:** Данные передаются как непрерывный поток байт. Границы между отдельными операциями `write()` на отправляющей стороне не сохраняются при `read()` на принимающей. Приложение должно само определять границы сообщений (например, используя разделители, префиксы с длиной).
* **Контроль:** Включает механизмы контроля потока (чтобы быстрый отправитель не перегрузил медленного получателя) и контроля перегрузки сети.
* **Использование:** Веб (HTTP/HTTPS), почта (SMTP, POP3, IMAP), передача файлов (FTP, SCP), удаленный доступ (SSH, Telnet) – везде, где важна надежность.

**UDP сокеты (`SOCK_DGRAM`):**
* **Тип:** `SOCK_DGRAM` (датаграммный) при вызове `socket()`.
* **Надежность:** Негарантированная доставка. Датаграммы могут теряться, дублироваться, приходить не по порядку. Надежность должна обеспечиваться на уровне приложения, если она необходима.
* **Соединение:** Не требуется установление соединения (connectionless). Каждая датаграмма отправляется независимо.
* **Датаграммы:** Данные передаются отдельными пакетами (датаграммами). Границы сообщений сохраняются: одна операция `sendto()` соответствует одной операции `recvfrom()`, которая читает всю датаграмму целиком (если буфер достаточно велик).
* **Контроль:** Нет встроенных механизмов контроля потока или перегрузки.
* **Использование:** DNS, DHCP, VoIP, потоковое видео/аудио, онлайн-игры – где важна скорость и допустимы некоторые потери, или где передаются небольшие запросы/ответы.

**18. Системные вызовы socket, bind, accept, recvfrom, sendto, select.**

Это ключевые системные вызовы из Berkeley Sockets API, используемые для сетевого программирования:

* **`socket(domain, type, protocol)`**:
    * **Назначение:** Создает новую конечную точку для коммуникации (сокет).
    * **Параметры:**
        * `domain`: Семейство протоколов (например, `AF_INET` для IPv4, `AF_INET6` для IPv6, `AF_UNIX` для локальных сокетов).
        * `type`: Тип сокета, определяет семантику обмена данными (`SOCK_STREAM` для TCP - потоковый, надежный, с установлением соединения; `SOCK_DGRAM` для UDP - датаграммный, ненадежный, без соединения).
        * `protocol`: Конкретный протокол (обычно 0, чтобы система выбрала протокол по умолчанию для указанного домена и типа).
    * **Возвращает:** Неотрицательный файловый дескриптор сокета в случае успеха, -1 в случае ошибки (`errno` содержит код ошибки).

* **`bind(sockfd, addr, addrlen)`**:
    * **Назначение:** Привязывает сокет к локальному адресу (IP-адресу и порту). Обычно используется на стороне сервера, чтобы клиенты знали, куда подключаться.
    * **Параметры:**
        * `sockfd`: Файловый дескриптор сокета, созданный `socket()`.
        * `addr`: Указатель на структуру `sockaddr`, содержащую адрес для привязки (например, `sockaddr_in` для IPv4, `sockaddr_in6` для IPv6). Структура должна быть заполнена семейством адресов, IP-адресом и портом.
        * `addrlen`: Размер структуры `addr` в байтах.
    * **Возвращает:** 0 в случае успеха, -1 в случае ошибки.

* **`accept(sockfd, addr, addrlen)`**:
    * **Назначение:** Извлекает первый запрос на соединение из очереди ожидающих соединений для слушающего сокета `sockfd` (который ранее был переведен в режим прослушивания с помощью `listen()`). Создает *новый* сокет для этого принятого соединения и возвращает его дескриптор. Используется только для сокетов с установлением соединения (например, TCP).
    * **Параметры:**
        * `sockfd`: Файловый дескриптор *слушающего* сокета.
        * `addr`: Указатель на структуру `sockaddr` (необязательный, может быть `NULL`), которая будет заполнена адресом подключившегося клиента.
        * `addrlen`: Указатель на `socklen_t` (необязательный, может быть `NULL`), который изначально содержит размер буфера `addr`, а после вызова будет содержать фактический размер адреса клиента.
    * **Возвращает:** Неотрицательный файловый дескриптор *нового сокета* для соединения с клиентом в случае успеха, -1 в случае ошибки. По умолчанию вызов блокируется, если в очереди нет входящих соединений.

* **`recvfrom(sockfd, buf, len, flags, src_addr, addrlen)`**:
    * **Назначение:** Получает данные из сокета. Может использоваться как для сокетов без установления соединения (UDP), так и с установлением соединения (TCP), но в основном предназначен для UDP, так как позволяет получить адрес отправителя.
    * **Параметры:**
        * `sockfd`: Файловый дескриптор сокета для чтения.
        * `buf`: Указатель на буфер для принятых данных.
        * `len`: Размер буфера `buf`.
        * `flags`: Флаги, модифицирующие поведение (например, `MSG_PEEK` - прочитать данные, не удаляя их из очереди).
        * `src_addr`: Указатель на структуру `sockaddr` (необязательный), которая будет заполнена адресом отправителя данных.
        * `addrlen`: Указатель на `socklen_t` (необязательный), который изначально содержит размер буфера `src_addr`, а после вызова будет содержать фактический размер адреса отправителя.
    * **Возвращает:** Количество принятых байт в случае успеха, 0 если удаленная сторона закрыла соединение (для TCP), -1 в случае ошибки.

* **`sendto(sockfd, buf, len, flags, dest_addr, addrlen)`**:
    * **Назначение:** Отправляет данные на указанный адрес через сокет. Основное назначение - отправка данных через сокеты без установления соединения (UDP).
    * **Параметры:**
        * `sockfd`: Файловый дескриптор сокета для записи.
        * `buf`: Указатель на буфер с отправляемыми данными.
        * `len`: Длина данных в буфере `buf`.
        * `flags`: Флаги, модифицирующие поведение.
        * `dest_addr`: Указатель на структуру `sockaddr`, содержащую адрес получателя.
        * `addrlen`: Размер структуры `dest_addr`.
    * **Возвращает:** Количество отправленных байт в случае успеха, -1 в случае ошибки.

* **`select(nfds, readfds, writefds, exceptfds, timeout)`**:
    * **Назначение:** Позволяет процессу ожидать события на *нескольких* файловых дескрипторах (включая сокеты) одновременно (мультиплексирование ввода/вывода). Можно проверить готовность к чтению, записи или наличие исключительных ситуаций.
    * **Параметры:**
        * `nfds`: Максимальный номер файлового дескриптора во всех наборах + 1.
        * `readfds`: Указатель на набор (`fd_set`) дескрипторов для проверки готовности к чтению.
        * `writefds`: Указатель на набор дескрипторов для проверки готовности к записи.
        * `exceptfds`: Указатель на набор дескрипторов для проверки исключительных ситуаций.
        * `timeout`: Указатель на структуру `timeval`, определяющую максимальное время ожидания. Если `NULL` - ждать бесконечно, если структура заполнена нулями - не ждать (просто проверить состояние).
    * **Возвращает:** Количество дескрипторов, готовых к операции, 0 если истек тайм-аут, -1 в случае ошибки. Наборы `readfds`, `writefds`, `exceptfds` модифицируются, оставляя только те дескрипторы, которые готовы.
    * **Примечание:** В Linux для работы с большим количеством дескрипторов более эффективными являются `poll()` и особенно `epoll()`. `select()` имеет ограничение на максимальный номер дескриптора (`FD_SETSIZE`) и менее эффективен при большом количестве отслеживаемых дескрипторов.

**19. Написание программы «прокси-сервер» на C.**

Прокси-сервер действует как посредник между клиентом и конечным сервером. Клиент подключается к прокси, прокси подключается к серверу назначения и передает данные между ними. Простейший (например, HTTP) прокси-сервер на C будет включать следующие шаги:

1.  **Настройка слушающего сокета:**
    * Создать TCP сокет (`socket`).
    * Установить опцию `SO_REUSEADDR` (`setsockopt`).
    * Привязать сокет к локальному IP и порту, на котором прокси будет слушать (`bind`).
    * Перевести сокет в режим прослушивания (`listen`).
2.  **Основной цикл приема клиентов:**
    * Бесконечный цикл для ожидания новых клиентов.
    * Вызвать `accept` для приема входящего клиентского соединения. При успешном `accept` получаем новый сокет (`client_sock`) для общения с этим клиентом.
    * Для обработки множества клиентов одновременно:
        * *Вариант 1 (простой):* Создать дочерний процесс (`fork`) или поток (`pthread_create`) для обработки каждого клиента.
        * *Вариант 2 (эффективный):* Использовать неблокирующие сокеты и мультиплексирование (`select`/`poll`/`epoll`) для управления всеми соединениями в одном потоке/процессе.
3.  **Обработка клиентского соединения (в отдельном потоке/процессе или через мультиплексор):**
    * **Чтение запроса клиента:** Прочитать данные (HTTP-запрос) из `client_sock` (`read`/`recv`).
    * **Парсинг запроса:** Определить метод (GET, POST, CONNECT...), целевой хост и порт из запроса. Для HTTP это обычно строка запроса (для GET) или заголовок `Host`. Для HTTPS (метод CONNECT) - сама строка запроса содержит `хост:порт`.
    * **Определение IP-адреса сервера:** Преобразовать имя хоста в IP-адрес с помощью `getaddrinfo()` (рекомендуется) или `gethostbyname()` (устаревшее).
    * **Установка соединения с сервером:**
        * Создать *новый* TCP сокет (`server_sock`).
        * Подключиться (`connect`) к полученному IP-адресу и порту целевого сервера. Если `connect` не удался, отправить клиенту ошибку (например, HTTP 502 Bad Gateway) и закрыть `client_sock`.
    * **Пересылка данных:**
        * Если метод был **CONNECT** (для HTTPS): Отправить клиенту ответ `HTTP/1.1 200 OK`. Далее просто пересылать данные "как есть" в обе стороны между `client_sock` и `server_sock` до закрытия одного из соединений.
        * Если метод был **GET/POST и др.** (для HTTP): Отправить исходный (возможно, слегка измененный) запрос клиента на `server_sock` (`write`/`send`). Затем пересылать данные в обе стороны.
        * **Механизм пересылки:** Наиболее эффективно использовать `select`/`poll`/`epoll` для одновременного мониторинга `client_sock` и `server_sock`. Если `client_sock` готов к чтению, читаем из него и пишем в `server_sock`. Если `server_sock` готов к чтению, читаем из него и пишем в `client_sock`.
    * **Завершение:** Когда одна из сторон закрывает соединение (`read` возвращает 0) или происходит ошибка, закрыть оба сокета (`client_sock` и `server_sock`) и завершить обработку этого клиента (завершить поток/процесс или удалить дескрипторы из `epoll`).
4.  **Очистка:** При завершении работы прокси-сервера закрыть слушающий сокет.

**20. Что такое RFC (Request for Comments), рассмотрение RFC про протокол HTTP.**

* **RFC (Request for Comments)**: Это серия документов, публикуемых Инженерным советом Интернета (IETF - Internet Engineering Task Force) и Обществом Интернета (ISOC - Internet Society). RFC охватывают широкий спектр тем, связанных с Интернетом: от детальных технических спецификаций протоколов (IP, TCP, UDP, DNS, HTTP, SMTP и др.) до концепций, процедур, обсуждений и информационных меморандумов. Многие RFC определяют стандарты Интернета. Хотя название "Запрос на комментарии" историческое, после публикации и одобрения многие RFC становятся официальными стандартами. Найти их можно на сайте IETF (www.rfc-editor.org).

* **RFC про протокол HTTP (HyperText Transfer Protocol):** HTTP - это протокол прикладного уровня для передачи гипермедийных документов (например, HTML). Он лежит в основе обмена данными во Всемирной паутине.
    * **Основные RFC:**
        * RFC 1945: Определял HTTP/1.0 (сейчас устарел).
        * RFC 2616: Долгое время был основным документом для HTTP/1.1 (сейчас устарел, заменен).
        * **RFC 7230-7235:** Текущая спецификация HTTP/1.1. Разделена на несколько документов:
            * RFC 7230: Message Syntax and Routing (Синтаксис сообщений, соединения).
            * RFC 7231: Semantics and Content (Методы GET, POST..., статус-коды, заголовки).
            * RFC 7232: Conditional Requests (Условные запросы, заголовки `If-Modified-Since`, `ETag`).
            * RFC 7233: Range Requests (Запросы диапазонов байт).
            * RFC 7234: Caching (Кэширование).
            * RFC 7235: Authentication (Аутентификация).
        * RFC 7540: HTTP/2 (Бинарный, мультиплексированный, сжатие заголовков).
        * RFC 9113: HTTP/3 (Использует QUIC вместо TCP).
    * **Ключевые аспекты HTTP/1.1 (из RFC 7230-7235):**
        * **Модель "Запрос-Ответ":** Клиент (браузер) отправляет запрос серверу, сервер обрабатывает его и возвращает ответ.
        * **Текстовый формат (в основном):** Запросы и ответы состоят из стартовой строки, заголовков (текст вида `Имя-Заголовка: Значение`) и необязательного тела сообщения.
        * **Стартовая строка запроса:** `Метод Ресурс ВерсияHTTP` (например, `GET /index.html HTTP/1.1`).
        * **Стартовая строка ответа (Status Line):** `ВерсияHTTP Код-Состояния Текстовое-Описание` (например, `HTTP/1.1 200 OK` или `HTTP/1.1 404 Not Found`).
        * **Методы:** Определяют действие над ресурсом (GET, POST, PUT, DELETE, HEAD, OPTIONS, CONNECT...).
        * **Заголовки (Headers):** Передают метаинформацию (например, `Host`, `User-Agent`, `Accept`, `Content-Type`, `Content-Length`, `Connection`).
        * **Соединения:** Могут быть постоянными (keep-alive), позволяя отправлять несколько запросов/ответов через одно TCP-соединение. Управляется заголовком `Connection`.
        * **Без сохранения состояния (Stateless):** По умолчанию сервер не хранит информацию о предыдущих запросах от того же клиента (состояние поддерживается с помощью cookies, сессий и т.д. на более высоком уровне).

**21. Создание и уточнение собственного протокола.**

Создание собственного протокола прикладного уровня может быть необходимо, если стандартные протоколы не подходят или избыточны для конкретной задачи.

**Шаги и соображения:**
1.  **Определить требования:** Что именно должны делать клиент и сервер? Какие данные передавать? Насколько важна надежность, скорость, безопасность?
2.  **Выбрать транспортный протокол:** TCP (для надежности и упорядоченности) или UDP (для скорости, если допустимы потери или порядок не важен, или если надежность реализуется поверх UDP)?
3.  **Формат сообщений (Framing):** Как определить границы сообщений в потоке данных (особенно актуально для TCP)?
    * **Разделители:** Использовать специальный символ или последовательность (например, `\r\n`, как в HTTP/SMTP, или нулевой байт). Проблема: разделитель не может встречаться в самих данных.
    * **Фиксированная длина:** Все сообщения имеют одинаковый размер. Просто, но негибко.
    * **Префикс длины:** Перед каждым сообщением передавать его длину (например, 4 байта с длиной, а затем сами данные). Наиболее гибкий и распространенный подход для бинарных протоколов.
    * **Самоописывающие форматы:** Использовать JSON, XML, Protobuf и т.п. Границы определяются парсером формата.
4.  **Кодирование данных:**
    * **Текстовый:** Проще отлаживать, человекочитаемый (например, JSON, XML, команды как строки). Учитывать кодировку (UTF-8).
    * **Бинарный:** Компактнее, потенциально быстрее парсить. Необходимо четко определить типы данных, их размеры и порядок байтов (network byte order - big-endian).
5.  **Типы сообщений/Команды:** Определить набор команд или типов сообщений, которыми обмениваются клиент и сервер (например, `LOGIN`, `MSG`, `USER_LIST`, `ERROR`, `PING`...).
6.  **Структура сообщений:** Для каждого типа сообщения определить его поля и их порядок/формат.
7.  **Управление состоянием:** Протокол будет с состоянием (сервер помнит контекст клиента) или без?
8.  **Обработка ошибок:** Как сообщать об ошибках? (Специальные сообщения об ошибках, коды состояния в ответах).
9.  **Версионирование и расширяемость:** Заложить возможность добавления новых команд/полей в будущем без нарушения совместимости со старыми клиентами/серверами.
10. **Безопасность:** Предусмотреть аутентификацию, шифрование (часто проще использовать TLS/SSL поверх вашего протокола).
11. **Документация:** Подробно описать протокол: форматы сообщений, последовательности обмена, коды ошибок и т.д.

**Уточнение:** В процессе реализации и тестирования протокол часто приходится уточнять: исправлять неоднозначности, добавлять недостающие команды, оптимизировать форматы.

**22. Реализация приложения «чат» для собственного протокола и клиентского приложения к чужому протоколу.**

**A. Чат на собственном протоколе:**
* **Протокол (Пример):**
    * Транспорт: TCP.
    * Фрейминг: Префикс длины (4 байта, network byte order) + тело сообщения.
    * Тело: JSON-объекты.
    * Команды (в поле `type` JSON-объекта):
        * Клиент -> Сервер: `login { "type": "login", "username": "user1" }`, `send_message { "type": "send_message", "to": "user2/all", "text": "Hello!" }`, `get_users { "type": "get_users" }`, `logout { "type": "logout" }`.
        * Сервер -> Клиент: `login_ok { "type": "login_ok" }`, `login_fail { "type": "login_fail", "reason": "..." }`, `user_list { "type": "user_list", "users": ["user1", "user3"] }`, `incoming_message { "type": "incoming_message", "from": "user1", "text": "Hello!" }`, `user_joined { "type": "user_joined", "username": "user4" }`, `user_left { "type": "user_left", "username": "user2" }`, `error { "type": "error", "message": "..." }`.
* **Сервер:**
    * Слушает на TCP-порту.
    * Использует `epoll` (или `select`/`poll`) для обработки множества клиентов асинхронно.
    * Хранит состояние: список подключенных пользователей (например, в `std::map<int, UserInfo>`), их сокеты.
    * Парсит входящие JSON-сообщения от клиентов (используя библиотеку типа `jansson`, `nlohmann/json` для C++).
    * Обрабатывает команды: `login` (проверка имени, добавление в список), `send_message` (находит сокет получателя и пересылает `incoming_message` или рассылает всем), `get_users` (отправляет `user_list`), `logout` (удаляет пользователя, рассылает `user_left`).
    * Формирует и отправляет JSON-ответы/уведомления клиентам.
    * Обрабатывает отключения клиентов (удаляет из списка, рассылает `user_left`).
* **Клиент:**
    * Подключается к серверу (`connect`).
    * Имеет основной цикл, использующий `select`/`poll`/`epoll` для одновременного ожидания:
        * Ввода от пользователя (из `stdin`).
        * Данных от сервера (из сокета).
    * При вводе от пользователя: формирует JSON (`send_message` или другие команды) и отправляет на сервер.
    * При получении данных от сервера: читает сообщение (учитывая префикс длины), парсит JSON, выводит на экран (`incoming_message`, `user_list`, `user_joined`, `user_left`, `error`) или обрабатывает иначе (`login_ok`/`fail`).
    * Отправляет `login` при старте, `logout` при выходе.

**B. Клиентское приложение к чужому протоколу (например, простой HTTP GET клиент):**
1.  **Разобраться с протоколом:** Изучить RFC 7230/7231 для HTTP/1.1 GET запроса и ответа.
2.  **Получить адрес:** Принять URL от пользователя, распарсить его на хост, порт (по умолчанию 80) и путь.
3.  **Определить IP:** Использовать `getaddrinfo()` для получения IP-адреса хоста.
4.  **Подключиться:** Создать TCP сокет (`socket`) и подключиться (`connect`) к IP-адресу сервера на нужный порт.
5.  **Сформировать HTTP запрос:** Создать текстовую строку запроса, например:
    ```
    "GET /path/to/resource HTTP/1.1\r\n"
    "Host: www.example.com\r\n"
    "Connection: close\r\n" // Просим сервер закрыть соединение после ответа
    "\r\n" // Пустая строка - конец заголовков
    ```
6.  **Отправить запрос:** Отправить строку запроса на сервер (`write`/`send`).
7.  **Прочитать ответ:** Читать данные из сокета (`read`/`recv`) в цикле, пока `read` не вернет 0 (соединение закрыто сервером) или -1 (ошибка).
8.  **Обработать ответ (опционально):**
    * Прочитать и вывести заголовки ответа.
    * Проверить код состояния (Status Code) в первой строке ответа.
    * Вывести тело ответа (например, HTML-код страницы).
9.  **Закрыть сокет:** Закрыть свой сокет (`close`).


**23. Криптографические хеши, их свойства.**

* **Определение:** Криптографическая хеш-функция — это математический алгоритм, который преобразует произвольный объем данных (входное сообщение) в строку фиксированного размера, называемую хеш-значением, хеш-суммой или просто хешем (digest). Этот хеш служит своего рода уникальным "отпечатком пальца" для входных данных.
* **Основные свойства:**
    1.  **Детерминированность (Determinism):** Один и тот же ввод всегда дает один и тот же хеш-вывод.
    2.  **Быстрота вычисления (Computational Efficiency):** Вычисление хеша для любого сообщения должно быть быстрым и эффективным.
    3.  **Сопротивление нахождению прообраза (Pre-image Resistance):** Имея хеш `h`, должно быть вычислительно невозможно (очень сложно) найти какое-либо входное сообщение `m`, такое что `hash(m) = h`. Невозможность восстановить исходные данные по хешу.
    4.  **Сопротивление нахождению второго прообраза (Second Pre-image Resistance):** Имея входное сообщение `m1`, должно быть вычислительно невозможно найти *другое* сообщение `m2` (`m1 ≠ m2`), такое что `hash(m1) = hash(m2)`. Невозможность подобрать другое сообщение с таким же хешем, как у заданного.
    5.  **Сопротивление коллизиям (Collision Resistance):** Должно быть вычислительно невозможно найти *любую пару* различных сообщений `m1` и `m2` (`m1 ≠ m2`), таких что `hash(m1) = hash(m2)`. Невозможность найти два *любых* разных сообщения с одинаковым хешем. Это самое сильное свойство, из него вытекают два предыдущих.
    6.  **Лавинный эффект (Avalanche Effect):** Любое, даже самое незначительное изменение во входных данных (например, изменение одного бита) должно приводить к существенному и непредсказуемому изменению хеш-значения (в идеале изменяется примерно половина бит хеша).
* **Примеры алгоритмов:** MD5 (считается небезопасным из-за найденных коллизий), SHA-1 (также считается слабым, не рекомендуется для криптографических целей), SHA-2 (семейство включает SHA-256, SHA-512 - текущие стандарты), SHA-3.
* **Применение:** Проверка целостности данных (сравнение хеша до и после передачи/хранения), хранение паролей (хранят хеши паролей, а не сами пароли), цифровые подписи, технология блокчейн, системы контроля версий (Git использует SHA-1/SHA-256 для идентификации объектов).

**24. Внутреннее устройство базы данных Git: blob, tree, commit, ref.**

Git хранит свои данные как набор объектов в папке `.git/objects`. Это, по сути, контентно-адресуемая файловая система. Имя объекта — это SHA-1 (или SHA-256 в новых версиях) хеш его содержимого. Существует четыре основных типа объектов:

1.  **Blob (Binary Large Object):**
    * **Содержимое:** Хранит сырое содержимое файла. Никаких метаданных вроде имени файла или прав доступа — только данные.
    * **Идентификация:** Идентифицируется SHA-хешем своего содержимого. Если в репозитории есть два файла с одинаковым содержимым (даже с разными именами), они будут указывать на один и тот же blob-объект.
2.  **Tree (Дерево):**
    * **Содержимое:** Представляет структуру каталога. Содержит список записей, по одной для каждого файла или подкаталога внутри этого каталога. Каждая запись включает:
        * Режим файла (права доступа).
        * Тип объекта (blob или tree).
        * SHA-хеш объекта (blob'а или поддерева), на который ссылается запись.
        * Имя файла или подкаталога.
    * **Идентификация:** Идентифицируется SHA-хешем своего текстового представления (списка записей). Дерево фиксирует состояние одного каталога (включая ссылки на содержимое файлов и подкаталоги).
3.  **Commit (Коммит):**
    * **Содержимое:** Представляет один снимок (snapshot) всего проекта в определенный момент времени. Содержит:
        * SHA-хеш корневого **tree**-объекта, который соответствует состоянию корневого каталога проекта для этого коммита.
        * SHA-хеш(и) родительских коммитов. Обычно один родитель, но у коммитов слияния (merge commits) их два или больше. Первый коммит не имеет родителей. Эта связь между коммитами образует историю проекта.
        * Информацию об авторе (имя, email, временная метка создания изменений).
        * Информацию о коммитере (имя, email, временная метка выполнения коммита; может отличаться от автора, например, при `rebase`).
        * Сообщение коммита.
    * **Идентификация:** Идентифицируется SHA-хешем своего содержимого (включая ссылки на дерево, родителей, метаданные и сообщение).
4.  **Ref (Ссылка):**
    * **Назначение:** Это не объект в `.git/objects`, а скорее указатель (обычно текстовый файл) на SHA-хеш коммита. Ссылки делают работу с историей удобнее, позволяя использовать человекочитаемые имена вместо полных хешей. Хранятся в основном в `.git/refs/`.
    * **Типы:**
        * **Heads (ветки):** Указывают на последний коммит в конкретной ветке (например, файл `.git/refs/heads/main` содержит SHA-хеш последнего коммита ветки `main`).
        * **Tags (метки):** Указывают на конкретный коммит, обычно для обозначения релизов (например, `.git/refs/tags/v1.0`). Могут быть легковесными (просто указатель) или аннотированными (являются отдельным объектом типа `tag`, содержащим информацию о создателе метки, сообщение, дату и указатель на коммит; могут быть подписаны GPG).
        * **HEAD:** Специальная ссылка (обычно символическая, хранящаяся в файле `.git/HEAD`), указывающая на текущую активную ветку (например, `ref: refs/heads/main`) или непосредственно на коммит (в состоянии "detached HEAD"). Определяет, на каком коммите основаны изменения в рабочем каталоге.

**25. Основные команды для работы с Git'ом.**

Вот список наиболее часто используемых команд Git:

* **Настройка и создание:**
    * `git config`: Настройка параметров Git (имя пользователя, email, редактор, псевдонимы и т.д.). Используется с флагами `--global` (для пользователя), `--system` (для системы) или `--local` (для репозитория, по умолчанию).
    * `git init`: Инициализирует новый пустой репозиторий Git в текущем каталоге.
    * `git clone <url>`: Клонирует (создает локальную копию) существующего удаленного репозитория.
* **Базовый рабочий процесс (создание коммитов):**
    * `git status`: Показывает состояние рабочего каталога и индекса (staging area) – измененные, добавленные в индекс, неотслеживаемые файлы.
    * `git add <файл(ы)>` или `git add .`: Добавляет изменения из рабочего каталога в индекс (staging area), подготавливая их к коммиту.
    * `git commit -m "сообщение"`: Сохраняет изменения из индекса в виде нового коммита с указанным сообщением.
    * `git diff`: Показывает различия между рабочим каталогом и индексом (незастейдженные изменения).
    * `git diff --staged` (или `--cached`): Показывает различия между индексом и последним коммитом (изменения, которые войдут в следующий коммит).
    * `git log`: Отображает историю коммитов. Множество опций для форматирования (`--oneline`, `--graph`, `--decorate`).
    * `git show <коммит>`: Показывает детальную информацию о конкретном коммите.
    * `git rm <файл>`: Удаляет файл из рабочего каталога и индексирует удаление.
    * `git mv <старое_имя> <новое_имя>`: Переименовывает файл и индексирует переименование.
    * `git restore <файл>`: Отменяет незастейдженные изменения в файле (возвращает к состоянию из индекса).
    * `git restore --staged <файл>`: Убирает файл из индекса (отменяет `git add`).
* **Ветвление и слияние:**
    * `git branch`: Показывает список веток, создает новую ветку.
    * `git checkout <ветка>` (или `git switch <ветка>`): Переключается на указанную ветку.
    * `git checkout -b <новая_ветка>` (или `git switch -c <новая_ветка>`): Создает новую ветку и переключается на нее.
    * `git merge <ветка>`: Вливает изменения из указанной ветки в текущую активную ветку.
    * `git branch -d <ветка>`: Удаляет локальную ветку (если она полностью слита).
* **Работа с удаленными репозиториями:**
    * `git remote -v`: Показывает список настроенных удаленных репозиториев.
    * `git remote add <имя> <url>`: Добавляет новый удаленный репозиторий.
    * `git fetch <удаленный_репозиторий>`: Загружает изменения (новые коммиты и ветки) из удаленного репозитория, но не применяет их к локальным веткам. Обновляет удаленные отслеживающие ветки (remote-tracking branches).
    * `git pull <удаленный_репозиторий> <ветка>`: Загружает изменения из удаленной ветки (`Workspace`) и затем сливает (`merge`) их с текущей локальной веткой.
    * `git push <удаленный_репозиторий> <ветка>`: Отправляет локальные коммиты из указанной ветки в удаленный репозиторий.

**26. «Переписывание истории» в Git.**

* **Что это:** Изменение существующих, уже созданных коммитов. Это может включать изменение сообщения коммита, добавление/удаление файлов, объединение нескольких коммитов в один, разделение одного коммита на несколько, изменение порядка коммитов. Важно понимать, что Git не *изменяет* старые коммиты, а создает *новые* коммиты с измененным содержимым или метаданными, которые заменяют собой старые. У новых коммитов будут другие SHA-хеши.
* **Зачем это нужно:**
    * Исправление ошибок в сообщениях коммитов.
    * Добавление забытых файлов в последний коммит.
    * Объединение мелких, промежуточных коммитов ("WIP", "fix typo") в один логически завершенный коммит.
    * Разделение большого коммита на несколько более мелких и понятных.
    * Удаление ошибочных или ненужных коммитов.
    * Изменение порядка коммитов для лучшей читаемости истории.
    * Удаление конфиденциальной информации или больших файлов из всей истории.
* **Команды:**
    * `git commit --amend`: Изменяет *самый последний* коммит. Позволяет изменить сообщение и/или добавить в него изменения из индекса. Создает новый коммит взамен предыдущего.
    * `git rebase -i <базовый_коммит>` (Интерактивный rebase): Мощный инструмент для изменения серии коммитов, идущих *после* указанного `<базового_коммита>`. Открывает редактор со списком коммитов и командами (`pick`, `reword`, `edit`, `squash`, `fixup`, `drop`). Позволяет изменять сообщения, объединять, удалять, переупорядочивать коммиты.
    * `git filter-branch` (устаревший) / `git filter-repo` (рекомендуемый): Инструменты для сложного и масштабного переписывания истории (например, удаление файла из всех коммитов, изменение email автора во всей истории).
* **Золотое правило и опасность:** **НИКОГДА не переписывайте историю, которая уже была отправлена (`push`) в общий/удаленный репозиторий и которую могли получить другие разработчики.** Это ломает их локальные копии истории и приводит к большим трудностям при синхронизации. Переписывание истории безопасно только для локальных коммитов, которые еще не были опубликованы. Если нужно исправить что-то в опубликованной истории, обычно используют новые коммиты для исправления (например, `git revert`).

**27. Связь между репозиториями.**

Git — это распределенная система контроля версий (DVCS). Каждый клон репозитория является полноценной копией со всей историей и возможностью работать независимо. Связь между этими копиями (репозиториями) осуществляется через механизм удаленных репозиториев (remotes).

* **Удаленные репозитории (Remotes):** Это просто псевдонимы (имена), связанные с URL-адресами других репозиториев. Когда вы клонируете репозиторий (`git clone`), Git автоматически создает remote с именем `origin`, указывающий на исходный URL. Вы можете добавлять другие remotes (`git remote add`).
* **Обмен изменениями:**
    * **`git fetch <remote>`:** Загружает все новые данные (коммиты, деревья, блобы) и обновляет состояние удаленных отслеживающих веток (например, `origin/main`) из указанного удаленного репозитория. `Workspace` не изменяет ваши локальные ветки или рабочий каталог.
    * **`git pull <remote> <branch>`:** Комбинация `git fetch` и `git merge` (или `git rebase`, если настроено). Загружает изменения с удаленной ветки и пытается слить их с вашей текущей локальной веткой.
    * **`git push <remote> <branch>`:** Отправляет ваши локальные коммиты (которые отсутствуют на удаленном сервере) из локальной ветки в указанную ветку удаленного репозитория. Требует прав на запись в удаленный репозиторий.
* **Удаленные отслеживающие ветки (Remote-tracking branches):** Это локальные ссылки (например, `refs/remotes/origin/main`), которые отражают состояние веток в удаленном репозитории на момент последнего `Workspace`/`pull`/`clone`. Они не перемещаются вашими локальными коммитами, а обновляются только при обмене данными с удаленным репозиторием. Они используются как точка отсчета для `pull`, `push` и для просмотра изменений, произошедших на сервере (`git log origin/main..HEAD`).
* **Рабочие процессы (Workflows):** Связь между репозиториями определяет рабочий процесс команды. Распространенные модели:
    * **Централизованная:** Все работают с одним центральным репозиторием (push/pull).
    * **Forking (на GitHub/GitLab):** Разработчики создают форк (личную серверную копию) основного репозитория, работают в своем форке, а затем предлагают изменения в основной репозиторий через Pull/Merge Requests.

**28. Настройка окружения для работы с Git'ом.**

Настройка Git выполняется с помощью команды `git config`. Настройки могут храниться на трех уровнях:

1.  **System (`--system`):** Настройки для всех пользователей системы (файл `/etc/gitconfig`). Требуются права администратора.
2.  **Global (`--global`):** Настройки для текущего пользователя (файл `~/.gitconfig` или `~/.config/git/config`). Наиболее часто используемый уровень для персональных настроек.
3.  **Local (`--local`, по умолчанию):** Настройки только для текущего репозитория (файл `.git/config` внутри репозитория). Переопределяют global и system настройки.

**Основные настройки:**
* **Имя пользователя и Email:** Обязательны, используются для указания авторства коммитов.
    ```bash
    git config --global user.name "Ваше Имя"
    git config --global user.email "ваш@email.com"
    ```
* **Текстовый редактор по умолчанию:** Используется для ввода сообщений коммитов.
    ```bash
    git config --global core.editor nano  # или vim, emacs, code --wait и т.д.
    ```
* **Имя ветки по умолчанию:** Рекомендуется использовать `main`.
    ```bash
    git config --global init.defaultBranch main
    ```
* **Обработка конца строк:** Важно для кроссплатформенной работы (Windows CRLF vs Linux/macOS LF).
    * Для Linux/macOS: `git config --global core.autocrlf input` (оставляет LF как есть, конвертирует CRLF в LF при коммите).
    * Для Windows: `git config --global core.autocrlf true` (конвертирует LF в CRLF при checkout, CRLF в LF при коммите).
* **Цветной вывод:**
    ```bash
    git config --global color.ui auto
    ```
* **Псевдонимы (Aliases):** Сокращения для часто используемых команд.
    ```bash
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
    ```
* **Просмотр настроек:**
    ```bash
    git config --list # Показать все настройки
    git config user.name # Показать конкретную настройку
    ```

**29. Установка, базовое использование, написание сценария сборки (Dockerfile).** (Подразумевается Docker)

* **Установка (Linux):**
    * Процесс зависит от дистрибутива. Обычно используется пакетный менеджер.
    * **Debian/Ubuntu:** `sudo apt update && sudo apt install docker.io` или следовать официальной инструкции Docker для установки Docker Engine (добавить репозиторий Docker, установить `docker-ce docker-ce-cli containerd.io`).
    * **Fedora:** `sudo dnf install docker`, затем `sudo systemctl start docker && sudo systemctl enable docker`.
    * **Arch Linux:** `sudo pacman -S docker`, затем `sudo systemctl start docker && sudo systemctl enable docker`.
    * **Добавление пользователя в группу `docker`:** Чтобы запускать docker без `sudo`: `sudo usermod -aG docker $USER`, затем нужно перелогиниться.
    * **Проверка:** `docker --version`, `docker run hello-world`.
* **Базовое использование (Команды Docker):**
    * `docker run [опции] <образ> [команда]`: Запустить контейнер из образа. Популярные опции: `-d` (фоновый режим), `-it` (интерактивный терминал), `--name <имя>`, `-p <порт_хоста>:<порт_контейнера>` (проброс портов), `-v <путь_хоста>:<путь_контейнера>` (монтирование тома).
    * `docker ps`: Показать запущенные контейнеры (`-a` для всех).
    * `docker images`: Показать скачанные образы.
    * `docker build -t <имя_тега> <путь_к_контексту>`: Собрать образ из Dockerfile (например, `docker build -t myapp .`).
    * `docker stop <id_или_имя_контейнера>`: Остановить контейнер.
    * `docker start <id_или_имя_контейнера>`: Запустить остановленный контейнер.
    * `docker rm <id_или_имя_контейнера>`: Удалить контейнер.
    * `docker rmi <id_или_имя_образа>`: Удалить образ.
    * `docker pull <образ>:<тег>`: Скачать образ из реестра (например, Docker Hub).
    * `docker push <образ>:<тег>`: Загрузить образ в реестр.
    * `docker logs <id_или_имя_контейнера>`: Показать логи контейнера (`-f` для слежения).
    * `docker exec -it <id_или_имя_контейнера> <команда>`: Выполнить команду внутри запущенного контейнера.
* **Написание сценария сборки (Dockerfile):**
    * **Назначение:** Текстовый файл с инструкциями для автоматической сборки Docker-образа.
    * **Основные инструкции:**
        * `FROM <базовый_образ>`: Задает родительский образ (например, `FROM ubuntu:22.04`). Первая инструкция в файле.
        * `WORKDIR /путь`: Устанавливает рабочий каталог для последующих инструкций (`RUN`, `COPY`, `CMD` и т.д.).
        * `COPY <источник_на_хосте> <путь_в_образе>`: Копирует файлы или папки из контекста сборки (с хоста) в файловую систему образа.
        * `RUN <команда>`: Выполняет команду в оболочке внутри образа во время сборки (например, установка пакетов: `RUN apt-get update && apt-get install -y vim`). Создает новый слой образа.
        * `EXPOSE <порт>`: Информирует Docker, что контейнер будет слушать на указанном порту во время выполнения (не публикует порт наружу, для этого используется `docker run -p`).
        * `CMD ["исполняемый_файл", "параметр1", "параметр2"]`: Задает команду по умолчанию, которая выполняется при запуске контейнера. Может быть переопределена при запуске (`docker run image new_command`).
        * `ENTRYPOINT ["исполняемый_файл", "параметр1"]`: Определяет основной исполняемый файл контейнера. Аргументы `docker run` добавляются после `ENTRYPOINT`. Сложно переопределить. Часто используется вместе с `CMD` для задания параметров по умолчанию.
        * `ENV <ключ>=<значение>`: Устанавливает переменные окружения.
        * `ARG <имя>[=<значение_по_умолчанию>]`: Определяет переменную времени сборки.
        * `USER <имя_или_UID>`: Задает пользователя для выполнения последующих команд и запуска контейнера.
        * `VOLUME ["/путь/в/контейнере"]`: Создает точку монтирования для внешнего тома.
    * **Пример Dockerfile (простое Python-приложение):**
        ```dockerfile
        # Базовый образ Python
        FROM python:3.9-slim

        # Рабочий каталог внутри контейнера
        WORKDIR /app

        # Копируем файлы зависимостей
        COPY requirements.txt requirements.txt

        # Устанавливаем зависимости
        RUN pip install --no-cache-dir -r requirements.txt

        # Копируем остальной код приложения
        COPY . .

        # Указываем порт, который будет слушать приложение
        EXPOSE 5000

        # Команда для запуска приложения
        CMD ["python", "app.py"]
        ```

**30. Технологии Linux, используемые в Docker.**

Docker не использует традиционную виртуализацию (как VirtualBox или VMware), а опирается на функции ядра Linux для изоляции и управления ресурсами контейнеров. Ключевые технологии:

1.  **Пространства имен (Namespaces):** Обеспечивают изоляцию. Позволяют процессам внутри контейнера иметь собственное представление о системных ресурсах, отличное от хоста и других контейнеров. Docker использует:
    * `pid` (Process ID): Своя нумерация процессов внутри контейнера (начинается с 1).
    * `net` (Network): Свой сетевой стек (IP-адреса, таблицы маршрутизации, порты).
    * `mnt` (Mount): Свое дерево файловой системы, изолированные точки монтирования.
    * `uts` (Unix Timesharing System): Свое имя хоста и домена.
    * `ipc` (Inter-Process Communication): Изоляция семафоров, разделяемой памяти.
    * `user` (User ID): Отображение пользователей и групп внутри контейнера на других пользователей/групп хоста для повышения безопасности (не всегда включено по умолчанию).
    * `cgroup`: Своя иерархия контрольных групп.
    * `time`: Свое представление о системных часах (monotonic и boottime).
2.  **Контрольные группы (Control Groups / cgroups):** Ограничивают и учитывают использование ресурсов (CPU, память, ввод/вывод диска, сеть) группой процессов. Docker использует cgroups для установки лимитов для контейнеров (`docker run --memory`, `--cpus` и т.д.), чтобы один контейнер не мог монополизировать ресурсы хоста.
3.  **Объединяемые файловые системы (Union File Systems):** Такие как `OverlayFS` (наиболее часто используемая), `AUFS`, `Btrfs`. Позволяют "накладывать" несколько файловых систем (слоев) друг на друга так, что они выглядят как единое целое. Docker использует это для создания слоев образов: базовый образ и последующие слои (от инструкций `RUN`, `COPY` и т.д.) являются read-only. При запуске контейнера поверх них добавляется тонкий read-write слой. Это делает образы компактными (слои переиспользуются) и запуск контейнеров быстрым.
4.  **Возможности (Capabilities):** Ядро Linux делит привилегии суперпользователя (root) на отдельные единицы (capabilities). Docker запускает контейнеры с ограниченным набором capabilities, убирая многие потенциально опасные, даже если процесс внутри контейнера работает от имени root (в своем user namespace).
5.  **Seccomp (Secure Computing Mode):** Фильтр системных вызовов. Docker применяет профиль seccomp по умолчанию, который блокирует множество системных вызовов, не нужных для типичной работы контейнера, что снижает поверхность атаки на ядро хоста.
6.  **AppArmor / SELinux:** Модули безопасности Linux (LSM), которые могут обеспечивать мандатный контроль доступа (MAC), дополнительно ограничивая доступ контейнеров к файлам, сети и другим ресурсам на основе заданных политик безопасности. Docker может интегрироваться с ними, если они включены на хосте.

Эти технологии позволяют Docker запускать приложения в изолированных окружениях с контролем ресурсов, используя общее ядро хостовой системы Linux.
