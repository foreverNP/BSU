# Навигация

- [1. Регулярные выражения](#1-регулярные-выражения)
- [2.1 Алфавит](#21-алфавит)
- [2.2 Проектирование ДКА, допускающего класс «идентификаторов» языка СИ](#22-проектирование-дка-допускающего-класс-идентификаторов-языка-си)
- [2.3 Свойства регулярных выражений и языков](#23-свойства-регулярных-выражений-и-языков)
- [3. Пересечение разбиений](#3-пересечение-разбиений)


# 1. Регулярные выражения

## 1. Что такое регулярные выражения?
Регулярные выражения – это способ описать множество строк (набор символов), которые удовлетворяют определённым правилам. Они позволяют задать шаблон, по которому можно проверить, подходит ли какая-то строка или нет.

## 2. Алфавит и базовые элементы
- **Алфавит (Σ):** Это набор символов, из которых будут строиться строки. Например, если Σ = {a, b, c}, то все наши строки будут состоять из букв a, b и c.
- **Элементарные регулярные выражения:**
  - **Символ a:** Если a – это символ из алфавита, то выражение **a** описывает язык, содержащий только строку "a". То есть L(a) = {a}.
  - **Символ ∅:** Обозначает пустой язык – набор строк, который не содержит ни одной строки.
  - **Символ λ (лямбда):** Обозначает пустую строку. То есть L(λ) = {λ} – язык, состоящий только из пустой строки.

## 3. Функция L – стандартная интерпретация
Функция **L** берёт любое регулярное выражение и показывает, какой язык (набор строк) оно описывает. Это как перевод из "языка шаблонов" в "набор строк".  
_Например, если у нас регулярное выражение **a**, то L(a) = {a}._

## 4. Функция D – диаграммы (графическое представление)
Функция **D** берёт регулярное выражение и строит для него схему – графическое представление недетерминированного конечного автомата (НКА). Этот автомат – как робот, который проверяет, соответствует ли данная строка шаблону регулярного выражения.  
_Таким образом, L показывает, что описывает выражение, а D – как можно "построить" автомат, который это распознаёт._

## 5. Составные регулярные выражения (индуктивный переход)
Из простых выражений можно создавать более сложные с помощью нескольких операций:
- **Скобки ( ):** Если взять выражение **e** и записать его в скобках, то язык остаётся тем же. То есть L((e)) = L(e).
- **Альтернация (|):** Запись **(e1 | e2)** означает, что строка может удовлетворять либо выражению e1, либо e2. Соответственно, L((e1 | e2)) = L(e1) ∪ L(e2).
- **Конкатенация:** Запись **(e1e2)** означает, что сначала идёт строка, подходящая под e1, а потом – строка, подходящая под e2. Тогда L((e1e2)) = L(e1)L(e2).
- **Итерация (звездочка *):** Запись **e*** означает повторение выражения e любое число раз (в том числе и 0 раз). L(e*) – это все возможные конкатенации строк из L(e), включая пустую строку.

## 6. Как строятся диаграммы (функция D)
Чтобы построить графическую схему (НКА) для сложного регулярного выражения, берут схемы для простых выражений и соединяют их по определённым правилам:
- **Для скобок:** Просто берут схему для e – никаких изменений.
- **Для альтернативы (|):** Соединяют две схемы так, чтобы автомат мог выбрать, с какого из двух путей идти.
- **Для конкатенации:** Последовательно соединяют схему для e1 со схемой для e2 – конец первого соединяется с началом второго.
- **Для звездочки (*):** Добавляют специальные переходы (λ-переходы), которые позволяют начать повторение, вернуться и закончить проверку, тем самым обеспечивая возможность повторять выражение произвольное число раз.

## Итог
- **L** – это способ понять, какой набор строк описывает регулярное выражение.
- **D** – это способ нарисовать автомат (схему), который сможет "распознать" эти строки.

Таким образом, теория показывает, как с помощью простых правил можно описывать сложные наборы строк и строить автоматические схемы для их распознавания.

# 2.1. Алфавит 

## 1. Класс «идентификаторов» языка Си

### Что такое идентификатор?  
В языке Си идентификатор – это имя (например, имя переменной), которое должно соответствовать определённому правилу. Оно всегда выглядит так:
- **Первая буква:** Должна быть именно буквой (это может быть как строчная, так и прописная) или знаком подчёркивания (`_`).
- **Остальные символы:** Могут быть как буквами, так и цифрами.

### Как записывается это правило с помощью регулярных выражений?  
- **[_A-Za-z]** – этот набор символов означает, что первый символ может быть либо подчёркиванием, либо любой буквой (от A до Z или от a до z).  
- **[_A-Za-z0-9]** – этот набор расширяет первый, добавляя цифры от 0 до 9. Он используется для всех последующих символов.  
- **[_A-Za-z0-9]\*** – оператор «Клини» (`*`) означает «любое число раз (в том числе 0) повторить». То есть это правило описывает любую последовательность символов из набора [_A-Za-z0-9].  

Когда мы объединяем всё вместе:  
**[_A-Za-z] [_A-Za-z0-9]\***  
мы получаем правило: «идентификатор – это слово, которое начинается с буквы или подчёркивания и продолжается любыми буквами, цифрами или подчёркиваниями».  

### Разбиение алфавита для идентификаторов  
Чтобы проще анализировать, какие символы «ведут себя одинаково» в этом правиле, делят весь входной набор символов (например, ASCII) на группы:
- **Группа 1:** Символы, разрешённые как первая буква – [_A-Za-z].  
- **Группа 2:** Символы, разрешённые для всех остальных позиций, но отличимые от первой группы – цифры [0-9].  
- **Группа 3:** Все остальные символы (те, которые вообще не могут входить в идентификатор) – обозначаются как [^_A-Za-z0-9].

Для удобства можно выбрать по одному представителю из каждой группы. Например:
- Пусть **a** представляет любую букву или подчёркивание (группа 1).
- Пусть **9** представляет любую цифру (группа 2).
- Пусть **?** представляет все недопустимые символы (группа 3).

Тогда правило можно записать в упрощённом виде:  
**a (a|9)\***  
Это значит: «начинается с a (то есть с буквы/подчёркивания), а дальше могут идти или буквы, или цифры».

## 2. Класс «целых восьмеричных констант» языка Си

### Что такое восьмеричная константа?  
В языке Си восьмеричная константа – это число, записанное в системе счисления с основанием 8. Оно записывается так:
- **Префикс:** Всегда начинается с цифры «0».
- **Основная часть (x):** За префиксом идёт последовательность (возможно пустая) цифр от 0 до 7.  
- **Суффикс (s):** Опционально может следовать буква (либо `l`/`L`, либо `u`/`U`), а также допускаются двухсимвольные комбинации вроде `ul` или `lu` (без учёта регистра).

### Как записывается это правило регулярными выражениями?  
- **[0]** – означает, что слово начинается с цифры «0».
- **[0-7]** – описывает, что последующие символы могут быть цифрами от 0 до 7.  
- **[0-7]\*** – означает, что может быть любая последовательность (в том числе и пустая) цифр от 0 до 7.
- **[lLuU]** – набор для односимвольных суффиксов (буквы l или u в любом регистре).
- **[Ll][Uu] | [Uu][Ll]** – это правило описывает двухсимвольные суффиксы (либо «lu», либо «ul», с возможностью менять регистр).

Соединяя всё вместе, получаем:  
**[0] [0-7]\* ([lLuU] | [Ll][Uu] | [Uu][Ll])?**  
Знак вопроса (`?`) означает, что часть с суффиксом может быть либо присутствующей, либо отсутствовать.

### Разбиение алфавита для восьмеричных констант  
Аналогично предыдущему случаю, разбиваем набор допустимых символов на группы:
- **Группа 1:** Символ [0] – префикс.
- **Группа 2:** Символы [1-7] – остальные цифры восьмеричной системы.
- **Группа 3:** Символы [l, L] – для суффикса.
- **Группа 4:** Символы [u, U] – для суффикса.
- **Группа 5:** Всё остальное, что не входит в предыдущие группы.

Опять же, можно выбрать представителей:
- Пусть **0** представляет сам символ «0».
- Пусть **7** представляет любую цифру от 1 до 7.
- Пусть **l** представляет букву L (или l).
- Пусть **u** представляет букву U (или u).
- Пусть **?** представляет все остальные недопустимые символы.

Тогда правило можно записать в упрощённом виде:  
**0 (0|7)\* (u|l|ul|lu)?**  
Это значит: «начинается с 0, потом идёт последовательность, состоящая из символов, которые либо 0, либо цифра от 1 до 7, а в конце может быть опциональный суффикс, который либо один символ (u или l), либо пара символов (ul или lu)».


## 3. Разбиение алфавита (эквивалентность символов)

### Идея эквивалентности символов  
Чтобы понять, почему мы можем заменить целые группы символов одним представителем, вводят понятие эквивалентности. Два символа называются эквивалентными относительно языка L, если:
- Для любых двух слов (любых строк) x и y вставка одного или другого символа между x и y не меняет того, принадлежит ли слово языку L.

Применяя это к нашему примеру:
- В классе идентификаторов все буквы и символ подчёркивания ведут себя одинаково – если они стоят на первой позиции, замена одной буквой другой не влияет на то, станет ли слово допустимым.
- Аналогично, все цифры ведут себя одинаково, если они используются не на первой позиции.

Таким образом, весь входной набор символов (например, ASCII) можно разделить на три группы:
1. Символы [_A-Za-z] – допустимы как первая буква.
2. Символы [0-9] – допустимы для последующих позиций.
3. Остальные символы – вообще недопустимы.

После этого можно взять по одному представителю из каждой группы и записать правило уже в виде абстрактного алфавита (например, B = {a, 9, ?}), где «a» заменяет все буквы и подчёркивания, «9» – все цифры, а «?» – все остальные.

## Итоговая запись  
- Для идентификаторов правило становится: **a (a|9)\***.  
- Для восьмеричных констант – правило: **0 (0|7)\* (u|l|ul|lu)?**.

## Вывод

Мы взяли сложные определения языковых конструкций и описали их с помощью регулярных выражений. При этом:
- **Первоначально** описываются все допустимые символы (алфавит) для каждой части конструкции.
- **Затем** с помощью операций конкатенации, выбора (альтернации) и оператора Клини строится полное правило для слова.
- **Наконец**, разбив алфавит на классы эквивалентных символов, можно заменить целые группы символов на одного представителя и получить упрощённое (абстрактное) правило.

# 2.2. Проектирование ДКА, допускающего класс «идентификаторов» языка СИ

## 1. Задача и спецификация

**Задача:**  
Нужно создать автомат (ДКА), который распознаёт идентификаторы языка Си. Идентификатор – это слово, которое:

- **Начинается** с буквы или подчёркивания (обозначим это символом **a**).
- **Далее** может идти любая последовательность символов, где каждый – либо буква/подчёркивание, либо цифра (обозначим цифру как **9**).

Все остальные символы (те, что не подходят ни под букву, ни под цифру) будем обозначать символом **?**. То есть мы разбиваем весь ASCII на три класса:

- **a:** допустимые начальные символы (буквы и подчёркивание).
- **9:** цифры.
- **?:** всё, что не входит в первые два набора.

Таким образом, основное регулярное выражение для идентификатора записывается как:  
  **e = a(a|9)\***  
(то есть, слово должно начинаться с a, а потом может идти любая последовательность a или 9).

## 2. Абстрагирование алфавита

Мы переходим от полного ASCII к абстрактному алфавиту:  
  Σ = {a, 9, ?}

Это позволяет работать с более простыми символами:

- **a** соответствует выражению [_a-zA-Z] (буквы и подчёркивание).
- **9** соответствует [0-9] (цифры).
- **?** соответствует [^_a-zA-Z0-9] (все остальные недопустимые символы).

## 3. Построение λ-диаграммы (НКА)

**λ-диаграмма** – это граф, который показывает, как можно перейти из одного состояния в другое при чтении символов (либо по реальным символам, либо по «пустым» переходам, обозначаемым λ).

- В этой диаграмме для нашего выражения **e = a(a|9)\***:
  - Сначала есть переход, читающий символ **a**.
  - Затем следует цикл, где при чтении **a** или **9** автомат переходит по определённым дугам.

Полученная диаграмма задаёт недетерминированный автомат (НКА) с λ-переходами, который распознаёт все строки, удовлетворяющие нашему правилу.

## 4. Преобразование НКА в ДКА

Чтобы автомат однозначно реагировал на каждый входной символ, преобразуют НКА в детерминированный автомат (ДКА). Его формальное определение:

  **ДКА = (Q, Σ, g, q₀, F)**

- **Q:** набор состояний (например, q₀, q₁, q₂, q₃).
- **Σ:** входной алфавит, у нас это {a, 9, ?}.
- **q₀:** начальное состояние. Здесь оно определяется как замыкание состояния {0} (обозначается [0]).
- **F:** множество финальных (принимающих) состояний. В нашем случае, это те состояния, которые содержат финальное состояние исходной λ-диаграммы.
- **g:** функция переходов, которая для каждого состояния и символа показывает, в какое состояние переходит автомат.

## 5. Таблица переходов и состояния

По построенной таблице получаем:

- **q₀ = [0] = {0}**  
  Из начального состояния (0) при чтении:
  - **a:** переходим в q₁ (так как g(q₀, a) = [μ({0}, a)] = [1] = {1,2,3}).
  - **9 или ?**: переход невозможен, получаем пустое множество (обозначим его как q₃).

- **q₁ = [1] = {1, 2, 3}**  
  Из этого состояния:
  - **a:** g(q₁, a) = q₂, где q₂ = {2, 3}.
  - **9:** g(q₁, 9) = q₂.
  - **?:** g(q₁, ?) = пустое множество (q₃).

- **q₂ = [2, 3] = {2, 3}**  
  Из этого состояния:
  - **a или 9:** остаёмся в q₂ (g(q₂, a) = q₂, g(q₂, 9) = q₂).
  - **?:** переход в пустое множество (q₃).

- **q₃ = {}** – состояние ошибки, куда попадают, если встретился недопустимый символ.

**Множество состояний:**  
  Q = {q₀, q₁, q₂, q₃}.

**Финальные состояния:**  
Принимающими оказываются те состояния, которые включают финальное состояние исходной λ-диаграммы. Здесь это q₁ и q₂.  
  F = {q₁, q₂}.

## 6. Функция переходов и замыкание

**Функция μ(S, a):**  
Для множества состояний S и символа a функция μ определяет, в какие состояния можно перейти, если из каждого состояния s ∈ S существует дуга с меткой a.

**Замыкание [S]:**  
При λ-переходах важно учитывать, что, находясь в состоянии s, можно перейти в другие состояния без чтения входного символа (то есть по λ).  
Замыкание [S] – это S вместе со всеми состояниями, достижимыми из S только по λ-дугам.

В ДКА переход определяется так:  
  **g(q, a) = [μ(q, a)]**  
То есть сначала берём множество состояний, куда можно перейти по символу a, а затем «дополняем» его λ-переходами.

**Расширенная функция переходов g\*(q, w):**  
Эта функция показывает, куда придёт автомат, если из состояния q прочесть целую строку w. Если итоговое состояние принадлежит F, то строка принимается.

## 7. Итоговое понимание

1. **Начало:**  
   Мы задаём правило для идентификаторов: слово должно начинаться с буквы или подчёркивания (a), а дальше может идти любая комбинация букв или цифр (a или 9).

2. **Абстракция:**  
   Приводим все символы к трем представителям: a, 9 и ?.

3. **λ-диаграмма:**  
   Создаётся НКА с λ-переходами по этому правилу.

4. **Построение ДКА:**  
   Из НКА строим ДКА, где состояния – это замыкания подмножеств состояний НКА. Таблица переходов показывает, как из каждого состояния по символам a, 9, ? происходит переход.

5. **Приём:**  
   Если автомат, прочитав слово, оказывается в одном из финальных состояний (q₁ или q₂), слово (идентификатор) принимается.

Таким образом, полученный ДКА является акцептором (распознавателем) идентификаторов языка Си. Он позволяет проверить, соответствует ли данная строка правилу: начинается с буквы/подчёркивания и содержит только допустимые символы.

# 2.3. Свойства регулярных выражений и языков

## 1. Формальные языки

**Алфавит и слова**

- **Алфавит (Σ):** Это набор символов. Например, если Σ = {a, b, c}, то «a», «b» и «c» – это символы.
- **Порядок и коды:** Каждый символ можно сравнить по порядку, используя его числовой код (например, в ASCII).
- **Слово:** Это последовательность символов. Например, слово «abc» состоит из символов «a», «b», «c». Длина слова – это число символов.
- **Пустое слово (λ):** Это слово, в котором нет ни одного символа. Его длина равна 0.
- **Σ\*:** Множество всех возможных слов, составленных из символов Σ (включая пустое слово).

**Операции над словами и языками**

- **Конкатенация (сцепление):** Объединение двух слов. Если у нас есть слово «ab» и слово «cd», их сцепление даст «abcd».
- **Моноид:** Множество Σ\*, где сцепление – операция, а пустое слово λ действует как нейтральный элемент (λw = wλ = w).
- **Формальный язык:** Любое подмножество Σ\*. Например, язык может содержать только те слова, которые удовлетворяют каким-то правилам.

**Операции над языками**

- **Объединение, пересечение, разность:** Это стандартные операции для множеств.
- **Конкатенация языков:** Если L и M – два языка, то LM = {wv | w ∈ L, v ∈ M}.
- **Особые языки:**
  - Пустой язык обозначается ⊘ (он не содержит ни одного слова).
  - Язык Λ = {λ} содержит только пустое слово.
- **Итерация (звезда Клини):**
  - L* = L⁰ ∪ L¹ ∪ L² ∪ …, где L⁰ = Λ. Это означает, что L* содержит пустое слово, все слова из L, слова из двух последовательных слов L и так далее.
  - Позитивная итерация L+ = L ∪ L² ∪ … (без пустого слова).

Эти операции удовлетворяют привычным свойствам: ассоциативности (например, (LM)N = L(MN)) и дистрибутивности (например, L(M ∪ N) = LM ∪ LN).

## 2. Тождества для регулярных выражений

Регулярные выражения – это способ описать языки (наборы слов). Из-за этого они подчиняются множеству математических свойств:

- **Базовые тождества:**
  - ⊘|e = e|⊘ – объединение с пустым языком ничего не меняет.
  - λe = eλ = e – конкатенация с пустым словом ничего не меняет.
- **Дистрибутивные законы:**
  - (e₁|e₂)e₃ = e₁e₃ | e₂e₃,
  - e₁(e₂|e₃) = e₁e₂ | e₁e₃.
- **Ассоциативные законы:**
  - (e₁|e₂)|e₃ = e₁|(e₂|e₃),
  - (e₁e₂)e₃ = e₁(e₂e₃).
- **Некоторые полезные тождества:**
  - e|e = e,
  - (λ|e)+ = e*,
  - (λ|e)* = e*,
  - e** = e*.

Эти равенства справедливы, потому что регулярные выражения описывают языки, и для языков выполняются те же свойства.

## 3. Специальные расширения регулярных выражений

**Элементарные выражения и квадратные скобки**

- **Элементарное аддитивное выражение:**  
  Выражение вида a₁|a₂|…|aₘ, где каждый aᵢ – символ из Σ, задаёт язык, состоящий из односимвольных слов {a₁, a₂, …, aₘ}.
  
- **Квадратные скобки:**  
  Чтобы записать множество символов компактно, используют квадратные скобки. Например:
  - [a-z] означает все строчные буквы,
  - [0-9] означает все цифры,
  - [A-F] означает буквы от A до F.
  
  Можно объединять диапазоны, например, [0-9A-F] или [A-F0-9]. Благодаря коммутативности объединения порядок внутри скобок не важен.

**Экранирование и числовые представления**

- Некоторые символы, которые сами являются метасимволами (например, (, ), +, *, [ и ]), нужно «экранировать» с помощью обратной косой черты, чтобы их воспринимали как обычные символы (например, \*, \(, \]).
- Также можно записывать символы через их числовые коды:
  - В восьмеричной системе, например, \053 означает символ «+», если его код равен 053.
  - В шестнадцатеричной системе, например, \x2B означает тот же символ.

## 4. Разбиение алфавита

**Что такое разбиение алфавита?**

- Разбиение алфавита – это разделение всего набора символов Σ на несколько непересекающихся групп (называемых классами), так что объединение всех этих групп даёт весь алфавит.
- Пример разбиения:  
  - Π₁ = { [_A-Za-z], [0-9], [^_A-Za-z0-9] }  
    Здесь:
    - [_A-Za-z] – буквы и подчёркивание,
    - [0-9] – цифры,
    - [^_A-Za-z0-9] – все остальные символы.
  
  - Другой пример:  
    - Π₂ = { [0], [1-7], [lL], [uU], [^01-7 lL uU] }  
    Здесь, например, цифра «0» выделена отдельно, а также отдельно группируются символы для суффиксов l и u (в разных регистрах).

**Пересечение разбиений**

- Если у нас есть два разбиения алфавита, мы можем их «пересечь»: это значит, для каждой группы из первого разбиения пересекаем её с каждой группой из второго разбиения.
- Результатом является набор новых групп, каждая из которых состоит из символов, принадлежащих и одной, и другой группе.
- В приведённом примере получается таблица, где видно, какие символы попадают в пересечение, и затем исходные группы можно выразить как объединение этих пересечений.

Например, если:
- Из Π₁ группа [_A-Za-z] пересекается с Π₂ группой [lL] – получаем [lL].
- Из Π₁ группа [0-9] пересекается с Π₂ группой [0] – получаем [0].
- И так далее.

Эти пересечения позволяют записать исходные разбиения через более мелкие группы, что полезно для точного описания, какие символы куда относятся.

## Итог

Мы рассмотрели основные понятия:
- **Формальные языки:** как множества слов над алфавитом, операции над ними (конкатенация, объединение, итерация) и их алгебраические свойства.
- **Регулярные выражения:** как способ описания языков с использованием специальных операций (альтернация, конкатенация, звезда Клини) и тождеств, которым они удовлетворяют.
- **Специальные расширения:** использование квадратных скобок для компактного задания наборов символов, экранирование метасимволов и числовые представления.
- **Разбиение алфавита:** как делить алфавит на непересекающиеся классы, а также как пересекать такие разбиения для более тонкого анализа.

Эти идеи лежат в основе теории формальных языков и широко используются, например, для построения компиляторов, анализа текстов и обработки данных.

# 3. Пересечение разбиений

## 1. Разбиение алфавита и его пересечения

### Разбиение алфавита  
Представьте, что у вас есть весь набор символов (например, ASCII). Мы можем разделить этот набор на группы (или классы) по различным признакам. В данном материале задают три разбиения:

- **Π₁:**  
  Делит алфавит на три класса:  
  - **[_a-zA-Z]** – буквы (как прописные, так и строчные, а также подчёркивание),  
  - **[0-9]** – цифры,  
  - **[^0-9_a-zA-Z]** – всё остальное (символы, не являющиеся ни цифрами, ни буквами/подчёркиванием).

- **Π₂:**  
  Здесь разбиение более тонкое (например, для определения целых восьмеричных констант):  
  - **[0]** – отдельная группа для символа «0»,  
  - **[1-7]** – цифры от 1 до 7,  
  - **[lL]** – символы «l» и «L»,  
  - **[uU]** – символы «u» и «U»,  
  - **[^01-7lLuU]** – все остальные символы, которые не попали в предыдущие группы.

- **Π₃:**  
  Разделяет символы на две группы:  
  - **[\x20\x09]** – символы пробела и табуляции (их коды: 0x20 и 0x09),  
  - **[^\x20\x09]** – все остальные.

### Абстрактные алфавиты  
Чтобы работать проще, каждую группу заменяют одним символом. Так получаются:
- **B₁ = {a, 9, ?}**  
  где «a» – представляет [_a-zA-Z], «9» – [0-9], а «?» – всё остальное.
- **B₂ = {0, 7, l, u, ?}**  
  Здесь, например, «0» соответствует классу [0], «7» – классу [1-7], «l» – [lL], «u» – [uU] и «?» – оставшимся символам.
- **B₃ = {s, ?}**  
  где «s» представляет пробельные символы ([\x20\x09]), а «?» – все остальные.

### Пересечение разбиений  
Мы можем совместить (пересечь) два разбиения, чтобы получить более тонкую классификацию. Здесь вычисляют:
- **Π₁,₂ = Π₁ ∩ Π₂**  
  Это значит, берём каждую группу из Π₁ и пересекаем её с каждой группой из Π₂. Например:  
  - Пересечение [_a-zA-Z] (из Π₁) с [lL] (из Π₂) даёт [lL].  
  - [_a-zA-Z] пересечённое с [^01-7lLuU] даёт оставшиеся буквы, которые не попали в [lL] и [uU] – записывается как [_a-km-tv-zA-KM-TV-Z].  
  - Аналогично, [0-9] можно разделить на [0], [1-7] и [89].  
  Итоговое пересечение:  
  **Π₁,₂ = { [0], [1-7], [lL], [uU], [89], [_a-km-tv-zA-KM-TV-Z], [^0-9_a-zA-Z] }.  

- **Π₁,₂,₃ = Π₁,₂ ∩ Π₃**  
  Мы ещё и учитываем разбиение на пробельные символы. Таким образом, получаем:  
  **Π₁,₂,₃ = { [0], [1-7], [lL], [uU], [89], [_a-km-tv-zA-KM-TV-Z], [\x20\x09], [^0-9_a-zA-Z\x20\x09] }.**

На основе этого пересечения вводится более подробный абстрактный алфавит:  
**B = {0, 7, 9, l, u, a, s, ?}**  
где каждая буква (например, 0, 7, l, u, a, s) соответствует своей группе из Π₁,₂,₃, а символ «?» – для оставшихся.

Далее исходные абстрактные алфавиты выражаются через B:  
- Для B₁ (идентификаторы):  
  - «a» (буква) равна объединению: a = a | l | u  
    (то есть, допустим, «буквой» может быть как обычная буква, так и символы из групп l и u).  
  - «9» (цифра) равна: 9 = 0 | 7 | 9  
  - «?» равна: ? = s | ?  
    (то есть, недопустимые для идентификатора символы могут быть представлены как пробельными или просто остальными).

Подобным образом можно выразить разбиения Π₂ и Π₃ через B, но в данном материале приводятся только результаты для Π₁.

## 2. Регулярные выражения в абстрактных алфавитах

Исходя из разбиений, для каждого языка \(L_i\) задаётся регулярное выражение \(e_i\) над соответствующим абстрактным алфавитом \(B_i\):

- **e₁ = a(a|9)\***  
  Описывает идентификаторы: слово должно начинаться с символа, представляющего букву (a), а далее может идти любое число символов, которые могут быть либо «a» (буквы) либо «9» (цифры).

- **e₂ = 0(0|7)\* (λ|u|l|ul|lu)**  
  Описывает, например, целые восьмеричные константы: начинается с 0, затем идёт последовательность символов, представленных как 0 или 7, а в конце может быть опциональный суффикс (либо ничего, либо u, либо l, либо их комбинация).

- **e₃ = s s\***  
  Описывает последовательность пробельных символов: хотя бы один символ, обозначенный буквой s, за которым могут следовать ещё такие же.

## 3. Декартово произведение (прямое произведение) ДКА

### Идея конструкции  
Когда нужно распознавать объединение (или, в некоторых случаях, пересечение) языков, можно построить новый детерминированный конечный автомат (ДКА), который представляет собой декартово произведение двух исходных ДКА.  
- Если у вас есть два автомата \(M_1\) и \(M_2\), то их произведение \(M_{1,2} = M_1 \times M_2\) имеет состояния, которые являются парами: \((q_1, q_2)\).
- Такой автомат будет одновременно отслеживать, куда могут прийти оба автомата, и, таким образом, сможет распознавать объединённый язык \(L_1 \cup L_2\).

### Таблица переходов  
В материале приведён пример таблицы переходов для \(M_{1,2}\), где строки – это состояния (например, (0,0), (2,1), (1,2) и т.д.), а столбцы – входные символы из абстрактного алфавита B = {0, 7, 9, a, l, u, s, ?}.  
Каждая ячейка таблицы показывает, в какое новое состояние переходит автомат, если он находится в данном состоянии и читает соответствующий символ.

## 4. Классификация состояний и переходов

### Состояния  
- **Активные состояния (Active):**  
  Это те состояния, которые достижимы из начального и из которых ещё можно продолжать распознавание.  
- **Состояния ошибки (Error):**  
  Если автомат переходит в такое состояние, это означает, что дальнейшее чтение уже не приведёт к корректному распознаванию лексемы (например, обнаружена ошибка в синтаксисе).

### Переходы  
Переходы (то, как автомат реагирует на входной символ) тоже делят на несколько типов:
- **ActiveTransition:**  
  Переходы между активными состояниями – «нормальные» переходы, когда всё идёт как надо.
- **EndLi:**  
  Переходы, после которых текущая лексема (например, идентификатор) заканчивается. То есть, если автомат читает символ, по которому дальнейшее распознавание невозможно, он фиксирует окончание лексемы.
- **ErrorL:**  
  Переходы, которые указывают на возникновение ошибки – например, когда прочитанный символ не может быть частью никакой допустимой лексемы.

### Семантические процедуры  
Чтобы лексический анализатор (сканер) знал, что делать при каждом переходе, вводится функция \(f: Q \times B' \to P\), где:
- \(Q\) – множество состояний автомата,
- \(B'\) – расширенный алфавит (B плюс специальный символ #, означающий конец потока),
- \(P\) – множество действий (например, «продолжить распознавание», «зафиксировать лексему», «сообщить об ошибке»).

Правила такие:
- Если переход – обычный (ActiveTransition), то выполняется действие \(pActiveTransition\).
- Если переход приводит к окончанию лексемы (EndLi), то выполняется действие \(pEndLi\) (для соответствующего языка).
- Если переход указывает на ошибку (ErrorL), то выполняется действие \(pErrorL\).

Эта функция \(f\) связывает состояние и входной символ с конкретным действием, которое должен выполнить лексический анализатор.

## Итог

Мы прошли следующие шаги:
1. **Разбиение алфавита:**  
   Исходный набор символов делится на группы по различным критериям (например, буквы, цифры, пробелы и прочее).

2. **Пересечение разбиений:**  
   Пересечение двух (или трёх) разбиений позволяет получить ещё более подробное разделение, которое затем представляется через абстрактный алфавит (например, B = {0, 7, 9, l, u, a, s, ?}).

3. **Регулярные выражения:**  
   На абстрактных алфавитах записываются регулярные выражения, описывающие нужные языки (например, идентификаторы, константы, пробелы).

4. **Конструкция автомата через декартово произведение:**  
   Для объединения языков строится ДКА, где каждое состояние – пара состояний исходных автоматов, а переходы задаются по символам абстрактного алфавита.

5. **Классификация состояний и переходов:**  
   Определяются активные и ошибочные состояния, а также типы переходов, что позволяет при распознавании лексем (например, при сканировании кода) корректно завершать распознавание или сигнализировать об ошибках.

6. **Семантические процедуры:**  
   Функция \(f(q,a)\) связывает состояния и входные символы с действиями лексического анализатора (продолжать, завершить лексему, сообщить об ошибке).

Эта теория является основой для построения лексических анализаторов в компиляторах, где важны как точное распознавание корректных лексем, так и своевременное обнаружение ошибок.

# 4.1. Декартово произведение двух автоматов

Попробую объяснить всё простыми словами, шаг за шагом.

## 1. Конгруэнтность и разбиение по классам

### Что такое конгруэнтность?  
Представьте, что у вас есть язык L – набор слов (например, корректных идентификаторов или констант). Мы говорим, что два слова x и y «эквивалентны по L» (обозначается x RLy), если замена одного слова на другое в любом контексте (то есть, для любых строк v и w, когда мы вставляем x или y между ними) не меняет того, принадлежит ли получившееся слово языку L.  
Это свойство (рефлексивность, симметричность, транзитивность) делает такое отношение эквивалентностью.

### Разбиение алфавита  
Поскольку L – регулярный язык, существует всего конечное число таких классов эквивалентности. В частности, можно разбить исходный набор символов (алфавит Σ) на группы, внутри которых все символы ведут себя одинаково для данного языка.  

Например, для лексем идентификаторов языка Си мы делим алфавит так:  
- **[_A-Za-z]** – буквы и знак подчёркивания.  
- **[0-9]** – цифры.  
- **[^_A-Za-z0-9]** – всё остальное, что не допускается.  

Из этих групп выбирают представителей, и получают так называемый «новый базис» для идентификаторов:  
  **B₍Id₎ = { a, 9, ? }**  
При этом символ **a** представляет все допустимые буквы, **9** – все цифры, а **?** – все недопустимые символы.

Аналогично для лексем «целых констант с основанием 8» выбирается другое разбиение, например:  
- **[0]**,  
- **[1-7]**,  
- **[lL]**,  
- **[uU]**,  
- **[^0-7lLuU]**.  
Это даёт базис:  
  **B₍Oct₎ = { 0, 7, l, u, ? }**.

## 2. Запись регулярных выражений на новых базисах

### Для идентификаторов  
Исходное регулярное выражение для идентификаторов записывается так:  
  **“[_A-Za-z][ _A-Za-z0-9]*”**.  
Если заменить группы на их представителей из B₍Id₎, получим:  
  **“a(a|9)*”**.

### Для восьмеричных констант  
Аналогично, выражение для целых восьмеричных констант выглядит примерно так:  
  **“0[0-7]*((l|L|λ)(u|U|λ)|(u|U)(l|L))”**.  
Перейдя на базис B₍Oct₎, его можно записать как:  
  **“0(0|7)*((l|λ)(u|λ)|ul)”**  
(при этом знак λ означает пустую строку).

## 3. Приведение к общему базису

Чтобы объединить два автомата (один для идентификаторов, другой для восьмеричных констант), нужно, чтобы они работали на одном «общем» алфавите. Для этого берут пересечение разбиений исходных базисов, то есть находят самое тонкое разбиение, которое учитывает и особенности идентификаторов, и особенности восьмеричных констант. В итоге получается общий базис:  
  **B = { 0, 7, l, u, 9, a, ? }**.

При этом символы из базиса идентификаторов выражаются через B так, например:  
- **a** (буква) = a ∪ l ∪ u,  
- **9** (цифра) = 0 ∪ 7 ∪ 9,  
- **?** (недопустимые) = остаётся как ? (а иногда ещё с пробельными символами, если они учитываются отдельно).

## 4. Конструирование детерминированных автоматов (ДКА)

### Из диаграмм к ДКА  
Для каждого регулярного выражения строят НКА (недетерминированный конечный автомат), а затем преобразуют его в ДКА.  
- Для идентификаторов — автомат A₁, построенный для выражения “a(a|9)*” на базисе B₍Id₎, затем преобразованный в автомат на общем базисе B.  
- Для восьмеричных констант — аналогичный автомат A₂ для выражения “0(0|7)*((l|λ)(u|λ)|ul)” на базисе B₍Oct₎, приведённый к общему базису B.

При этом, если в исходном автомате переход по символу, например, “9” на частном базисе, то в автомате на общем базисе этот переход может заменяться переходами по всем символам, которые входят в группу, соответствующую “9” (то есть по 0, 7 или 9).

### Декартово произведение автоматов  
Чтобы получить автомат, который распознаёт объединение языков (в нашем случае, поскольку идентификаторы и восьмеричные константы не пересекаются, их объединение), строят декартово произведение автоматов A₁ и A₂.  
- Каждый новый статус представляет собой пару состояний (одно из A₁ и одно из A₂).  
- Функция переходов в произведении определяется так: если в A₁ переход по символу a ведёт из состояния q₁ в p₁, а в A₂ аналогичный переход ведёт из q₂ в p₂, то в декартовом автомате при прочтении a состояние (q₁, q₂) переходит в (p₁, p₂).

## 5. Классификация состояний и переходов

### Состояния  
Автомат делят на два типа:  
- **Active (активные):** состояния, из которых можно продолжать распознавание корректной лексемы.  
- **Error (ошибочные):** состояния, из которых никакая дальнейшая последовательность не приведёт к распознанию корректной лексемы. Обычно таких состояний в построенных автоматах очень мало (часто всего одно).

### Переходы  
Переходы (дуги) классифицируют следующим образом:
- **ActiveTransition:** переходы между активными состояниями, когда всё идёт «по плану».  
- **EndLᵢ:** переходы, при которых лексема заканчивается. Если автомат в состоянии, относящемся к языку Lᵢ (например, идентификаторы или восьмеричные константы), и дальнейший символ приводит к переходу в состояние ошибки, это сигнализирует, что лексема закончилась.  
- **ErrorL:** переходы, которые непосредственно приводят к состоянию ошибки, сигнализируя о том, что прочитанный символ не может быть частью никакой корректной лексемы.

## 6. Семантические процедуры: что делает лексический анализатор

Чтобы лексический анализатор знал, как реагировать на каждый переход автомата, вводится функция выхода \( f: Q \times B \to P \), где:
- **Q** — множество состояний автомата,
- **B** — общий входной алфавит,
- **P** — набор «действий» или семантических процедур.

При этом:
1. **Активный переход (ActiveTransition):**  
   Когда автомат находится в активном состоянии и переход происходит по нормальному символу, выполняется действие, которое просто обновляет текущее состояние и продолжает считывание.
2. **Завершение лексемы (EndLᵢ):**  
   Если автомат находится в состоянии, которое соответствует завершению лексемы Lᵢ (например, идентификатора или восьмеричной константы), и следующий символ не может быть продолжением этой лексемы, то лексический анализатор:
   - Сохраняет распознанную лексему в таблице символов,
   - Выводит соответствующий токен (например, <идентификатор, w>),
   - Возвращает символ назад в поток (так как он может быть началом следующей лексемы),
   - Сбрасывает автомат в начальное состояние.
3. **Ошибка (ErrorL):**  
   Если переход приводит к состоянию ошибки, анализатор регистрирует ошибку (например, позицию и характер ошибочного символа) и сбрасывается в начальное состояние для начала распознавания следующей лексемы.

Таким образом, итоговая модель лексического анализатора представляется как автомат с выходом:  
  **M = (Q, B, P, g, f, q₀, F)**,  
где g – функция переходов, f – функция семантических действий, q₀ – начальное состояние, F – множество финальных состояний (разбитое на F₁ и F₂ для разных классов лексем).

## Итоговое понимание

1. **Конгруэнтность** позволяет разбить алфавит на группы, в которых символы ведут себя одинаково для данного регулярного языка.
2. Для двух лексических классов (идентификаторов и восьмеричных констант) строятся свои разбиения и выбираются соответствующие базисы (B₍Id₎ и B₍Oct₎).
3. Чтобы объединить оба автомата, их приводят к **общему базису** (B), который получается как пересечение исходных разбиений.
4. Затем для каждого языка строятся ДКА (сначала в «частных» базисах, потом преобразуются в общий).
5. Конечный автомат для объединённого языка строится как **декартово произведение** этих двух ДКА.
6. Автомат разделяют на активные и ошибочные состояния, а его переходы – на нормальные, завершающие лексему и ошибочные.
7. **Семантические процедуры** (выходная функция f) задают, какие действия должен выполнить анализатор: продолжить распознавание, завершить лексему или сообщить об ошибке.

В результате получается модель лексического анализатора, которая при сканировании входного потока символов определяет, к какому классу принадлежит очередная лексема (идентификатор или восьмеричная константа) или обнаруживает ошибку, и выполняет соответствующие действия (сохранение токена, уведомление об ошибке, сброс состояния).

# Соглашение о лексике

Этот фрагмент – выдержка из справочного руководства по языку Си, которое основано на ANSI-стандарте от 31 октября 1989 года. Ниже приведено краткое и простое объяснение основных моментов:

### 1. Общая идея руководства

- **Назначение документа:**  
  Руководство описывает язык Си согласно ANSI-стандарту. Это не сам стандарт, а надежное описание языка, предназначенное для пользователей и разработчиков.

- **Структура описания:**  
  Документ в целом следует схеме, принятой в стандарте, хотя есть организационные и терминологические отличия от оригинала.

### 2. Фазы трансляции и лексический анализ

- **Единицы трансляции:**  
  Программа Си состоит из одного или нескольких файлов (единиц трансляции). Каждый файл проходит несколько этапов обработки (например, препроцессирование, разбиение на лексемы).

- **Препроцессор:**  
  На ранних этапах обрабатываются директивы (начинающиеся с символа #), макросы и комментарии. По завершении работы препроцессора программа представляется в виде последовательности лексем (токенов).

### 3. Лексемы (tokens)

- **Классы лексем:**  
  В языке Си выделяют шесть типов лексем:  
  - **Идентификаторы** (имена переменных, функций и т.д.),  
  - **Ключевые слова** (зарезервированные слова, такие как if, while, return и т.д.),  
  - **Константы** (числовые, символьные, перечислимые и константы с плавающей точкой),  
  - **Строковые литералы** (текст в двойных кавычках),  
  - **Операторы** (например, +, -, *, / и т.д.),  
  - **Разделители** (символы, разделяющие лексемы, такие как запятые, скобки и т.п.).

- **Разделители:**  
  Пробелы, табуляции, новые строки и комментарии служат только для разделения лексем и не влияют на смысл программы.

- **Принцип максимальной длины:**  
  Если входной поток уже разделён на лексемы, то следующей лексемой считается максимально длинная последовательность символов, которая может составлять лексему.

### 4. Комментарии

- **Синтаксис комментариев:**  
  Комментарии начинаются с последовательности `/*` и заканчиваются `*/`.  
- **Ограничения:**  
  Комментарии нельзя вкладывать друг в друга или размещать внутри строковых литералов.

### 5. Идентификаторы

- **Правила формирования:**  
  Идентификатор – это последовательность букв и цифр, при этом первый символ обязательно должен быть буквой (а знак подчёркивания _ считается буквой).  
- **Чувствительность к регистру:**  
  Прописные и строчные буквы различаются, то есть «Var» и «var» – разные идентификаторы.  
- **Ограничения длины:**  
  Идентификаторы могут быть любой длины, но для внутренних целей (например, имена макросов) значимыми считаются только первые 31 символ, а для внешних (связанных с другими файлами) может учитываться только, скажем, первые 6 символов.

### 6. Ключевые слова

- **Зарезервированные слова:**  
  Приводится список слов (например, auto, break, case, char, const, continue, do, if, switch и т.д.), которые нельзя использовать как идентификаторы, потому что они имеют специальное значение в языке.

### 7. Константы

#### 7.1. Целые константы

- **Запись:**  
  Последовательность цифр. Если начинается с 0 – константа интерпретируется как восьмеричная (и не должна содержать 8 или 9), если с 0х или 0Х – как шестнадцатеричная, иначе – как десятичная.
- **Суффиксы:**  
  Суффиксы u (или U) указывают на беззнаковость, l (или L) – на тип long. Порядок выбора типа (int, long int, unsigned long int и т.д.) зависит от записи константы.

#### 7.2. Символьные константы

- **Запись:**  
  Символьная константа заключается в одинарные кавычки, например, 'x'. Если в кавычках один символ, то значение – числовой код этого символа.
- **Escape-последовательности:**  
  Для включения специальных символов (например, новой строки, табуляции, обратной косой черты, одинарной кавычки) используются последовательности вроде `\n`, `\t`, `\\`, `\'`.
- **Расширенные символьные константы:**  
  Если перед кавычками стоит буква L, например, L'х', то это расширенная символьная константа (тип wchar_t).

#### 7.3. Константы с плавающей точкой

- **Структура:**  
  Состоят из целой и дробной частей, десятичной точки, возможно, экспоненты (e или E) и суффикса, определяющего тип (f/F для float, l/L для long double, а если нет суффикса – double).

#### 7.4. Константы-перечисления

- **Особенности:**  
  Идентификаторы, объявленные в перечислениях, рассматриваются как константы типа int.

### 8. Строковые литералы

- **Определение:**  
  Строковой литерал – это последовательность символов, заключенная в двойные кавычки, например, "Hello, world!".  
- **Хранение:**  
  Строковые литералы представляют массив символов, хранящийся в статической памяти.  
- **Конкатенация:**  
  Если в коде указаны две строковые литералы подряд, они автоматически объединяются в одну строку, и в конце добавляется символ NULL (\0), чтобы указать конец строки.  
- **Ограничения:**  
  В строковых литералах нельзя напрямую писать символ новой строки или двойную кавычку – для этого используются escape-последовательности.  
- **Расширенные строковые литералы:**  
  Если литерал начинается с L, например, L"Привет", он предназначен для широких символов и имеет тип "массив из wchar_t". Смешивание обычных и расширенных строк не допускается.

### Итог

Этот фрагмент справочного руководства дает представление о том, как в языке Си организованы лексические элементы:
- Как программа разбивается на лексемы,
- Какие классы лексем существуют (идентификаторы, ключевые слова, константы, строковые литералы, операторы и разделители),
- Как записываются и обрабатываются идентификаторы, комментарии, константы различных типов и строковые литералы.

Всё это важно для компиляторов языка Си, поскольку именно на основании этих правил происходит разбиение исходного кода на базовые элементы, из которых затем строится синтаксическое и семантическое представление программы.