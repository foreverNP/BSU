# АЛГОРИТМ ТАБЛИЧНОГО ВЫВОДА ДЛЯ БЗ "ПРОДУКЦИОННОГО" ТИПА

## Предварительные обозначения.
Пусть заданы n признаков, которые имеют наименования $A_1,\ldots,A_n$. Каждому такому признаку $A_i$ можно поставить в соответствие набор значений $(a_{i1},\ldots,a_{ik_i})$.

## Пример (по БЗ на стр. 2):
$A_1$=семейство, $(a_{11} = \text{кипарисовые}, a_{12} = \text{сосновые}, a_{13} = \text{еловые}, a_{14} = \text{болотный кипарис})$;

$A_2$=класс, $(a_{21} = \text{голосеменные})$;

$A_3$=структура листа, $(a_{31} = \text{чешуеобразная}, a_{32} = \text{иглоподобная})$.

В общем случае правило продукции с помощью признаков $A_i$ и их значений $(a_{i1},\ldots,a_{ik_i})$ может быть представлено с использованием пар $(A_i, a_{ij} ), j \in \{1,2,\ldots,k_i\}$ в следующем виде:

$$P = (A_u, a_{uk})\wedge\ldots\wedge(A_v, a_{vl}) \Rightarrow (A_s, a_{sm}),$$

$u, v, s \in \{1,2,\ldots,n\}; k \in \{1,2,\ldots,k_u\}, l \in \{1,2,\ldots,k_l\}, m \in \{1,2,\ldots,k_m\}$.

После приведения к КНФ получим:

$$P = \neg(A_u, a_{uk})\vee\ldots\vee\neg(A_v, a_{vl})\vee(A_s, a_{sm}),$$

## Пример:
$$P_1 = (A_2, a_{21})\wedge(A_3, a_{31}) \Rightarrow (A_1, a_{11}) \Leftrightarrow P_1 = \neg(A_2, a_{21})\vee\neg(A_3, a_{31})\vee(A_1, a_{11})$$

Предположим теперь, что БЗ содержит $t$ правил $P_1,\ldots,P_t$ $(t\in \mathbb{N})$. Приведем их все к КНФ и построим **таблицу правил**:

| | Посылочные признаки | | | | Заключительные признаки | | | |
|---|---|---|---|---|---|---|---|---|
| | $A_1$ | $A_2$ | ... | $A_n$ | $A_1$ | $A_2$ | ... | $A_n$ |
| | $a_{11} \ldots a_{1k_1}$ | $a_{21} \ldots a_{2k_2}$ | | $a_{n1} \ldots a_{nk_n}$ | $a_{11} \ldots a_{1k_1}$ | $a_{21} \ldots a_{2k_2}$ | | $a_{n1} \ldots a_{nk_n}$ |
| $P_1$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ |
| ... | | | | | | | | |
| $P_t$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ | $b$ |

Таблица заполняется в соответствии со следующим правилом:
Символы $b$ в ячейке с индексом $(i,j)$ принимают значения из множества {ப, +, −} в соответствии со следующими правилами. Фиксируем $P_u$ и в клетки соответствующей строки заносим:
$b$=ப (ничего не ставится, пробел) если признак $A_i$ (как среди посылочных, так и заключительных) со значением $a_{ij}$ не используется в правиле;

$b$=−, если признак $A_i$ является посылочным и его значение $a_{ij}$ используется в правиле;

$b$=+, если признак $A_i$ является заключительным и его значение $a_{ij}$ используется в правиле.

## АЛГОРИТМ.

**Шаг 0.** Модифицируем таблицу правил, оставив в ней только те посылочные и заключительные признаки, которые имеют значащие значения ({+,−}) хотя бы для одного правила из набора $P_1,\ldots,P_t$. Обозначим полученную таблицу (матрицу) через $T_{пр}$. В результате получим **два набора признаков** – $A_{пос}$ (посылочные) и $A_{закл}$ (заключительные). Сформируем также **стек целей** $St_{target}$ и **список полученных результатов** $L_{res}$, которые будут применяться в процессе вывода. Состоять они будут:
- $St_{target}$ из последовательности признаков $A_u \in A_{закл}$;
- $L_{res}$ из последовательности установленных фактов в виде $(A_u, a_{uj})$: $A_u \in A_{пос} \vee A_{закл}$, $j \in \{1,2,\ldots,k_u\}$.

> Задаем пользователю вопрос – какой из признаков из набора $A_{закл}$ он желает вывести. Предположим, что ответ был такой – признак $A_i \in A_{закл}$.

Заносим признак $A_i$ в стек $St_{target}$.

**Шаг 1.** Формируем таблицу $T_{goals}$, которую по определению полагаем пустой (т.е. шапка и нет строк).

**Шаг 1.1.** Для текущего признака $A_{current} \in St_{target}$ заносим в таблицу $T_{goals}$ строки, соответствующие правилам, у которых заключительный признак $A_{current}$ для одного из значений помечен знаком '+'. Соответствующий набор правил обозначим $P_{current}$. Если $P_{current} = \emptyset$ то переходим на шаг 1.2. В противном случае ($P_{current} \neq \emptyset,)$ – на шаг 2.

**Шаг 1.2.**
Сообщаем пользователю:

> Ответ не может быть получен т.к. отсутствуют правила, соответствующие признаку $A_{current}$.

переходим на шаг 6.

**Шаг 2.** В таблице $T_{goals}$ находим строку (пусть для определенности это будет строка, соответствующая правилу $P_u \in P_{current}$), у которой число признаков, помеченных знаком '−' минимально.

Если это число больше 0, то переходим к шагу 3.

В противном случае (равно 0) – заносим $A_{current}$ и соответствующее ему значение в правиле $P_u$ в $L_{res}$ (обозначим полученный результат для определенности через $(A_v, a_{vs})$) и в случае |$St_{target}$| = 1 переходим к шагу 5. В противном случае (|$St_{target}$| > 1) – к шагу 4.

**Шаг 3.** Выбираем первый признак в правиле $P_u$, помеченный знаком '−'. Пусть это будет признак $A_v$. Если $A_v \notin A_{закл}$, то:

> Задаем пользователю вопрос – какое значение имеет признак $A_v$. Предположим, что ответ был такой – $a_{vs}$.

Заносим полученный ответ $(A_v, a_{vs})$ в $L_{res}$ и переходим к шагу 4.

В противном случае ($A_v \in A_{закл}$) заносим $A_v$ в $St_{target}$ делая его $A_{current}$ и переходим на шаг 1.1.

**Шаг 4.**
Применяем к матрице $T_{goals}$ следующие преобразования.

**Шаг 4.1.** Последовательно фиксируем все строки (правила $P_u$) из $T_{goals}$. Если просмотрены все строки, то переходим к шагу 4.2.

**Шаг 4.1.** Если $A_v \in A_{пос}$ в правиле $P_u$, то переходим к шагу 4.1.1 Если $A_u \in A_{закл}$ в правиле $P_u$, то переходим к шагу 4.1.2.

**Шаг 4.1.1.**
- Если признак $A_v$ является значащим (помечен знаком '−'), причем в позиции, которая не совпадает с номером $s$, то правило $P_u$ исключаем из $T_{goals}$. Переходим к шагу 4.1;
- Если $A_v$ является значащим (помечен знаком '−') и пара $(A_v, a_{vs})$ также помечена знаком '−', то правило $P_u$ исключаем из $T_{goals}$. Переходим к шагу 4.1;
- Если $A_v$ является значащим (помечен знаком '−'), причем в позиции, которая совпадает с номером $s$, то знак '−' заменяется на 'ப'. Переходим к шагу 4.1;

**Шаг 4.1.2.**
- Если $A_v$ является помечен знаком '+' в позиции, которая не совпадает с номером $s$, то соответствующее ему значение $a_{us}$ в виде $−(A_u, a_{us})$ заносим в $L_{res}$, а правило $P_u$ исключаем из $T_{goals}$. Переходим к шагу 4.1;
- Если $A_v$ является помечен знаком '+' в позиции, которая совпадает с номером $s$, то правило $P_u$ исключаем из $T_{goals}$. Переходим к шагу 4.1;

**Шаг 4.2.** Обновляем таблицу $T_{goals}$ (помечаем удаленные правила $P_u$, чтобы не просматривать их в дальнейших шагах алгоритма) и переходим к шагу 3.0.

**Шаг 4.3.** Обнуляем список $L_{res}$, исключая из него все пары $(A_v, a_{vs})$. Если значение $A_{current}$ установлено, то исключаем из $St_{target}$ признак $A_{current}$. Меняем значение $P_{current}$ (т.к. в стеке будет новое значение $A_{current}$) и переходим к шагу 2.

**Шаг 5.** Сообщаем пользователю ответ:

> Признак $A_v$ имеет значение $a_{vs}$. (здесь пара $(A_v, a_{vs})$ - последняя из занесенных в $L_{res}$).

**Шаг 6.** Конец работы алгоритма.

**Требования к программному продукту** аналогичны изложенным на стр. 4. Кроме того, необходимо в программе вывести на экран последовательность $T_{goals}$