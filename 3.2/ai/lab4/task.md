# Задача распознавания

## Постановка задачи T₀(ask)

В итоге выбранная для лабораторных работ 4 и 5 задача (обозначим ее для краткости через T₀(ask)) должна удовлетворять следующей постановке:

### ЗАДАНЫ:
- некоторое множество объектов $X$, разбитое на подмножества (классы) $X_1, ..., X_l$ ($l \in \mathbb{N}$). Причем, классы не пересекаются $X_i \cap X_j = \emptyset \; \forall i \neq j \; (i, j \in \{1, ..., l\})$.
- выборка объектов $X^0 \subset X$, которая удовлетворяет условиям: $|X^0| < +\infty$ и $X^0 \cap X_i \neq \emptyset$ (∀i ∈ {1, ..., l}). Кроме того, для каждого объекта $x \in X^0$ известна (определена) информация о принадлежности к классам $X_1, ..., X_l$. Эта информация задается в виде **информационного вектора** $P(x) = (P_1(x), ..., P_l(x))$, компоненты которого определяются следующим образом

$$P_i(x) = \begin{cases}
1, \text{если } x \in X_i, \\
0, \text{иначе}.
\end{cases}$$

## ЗАДАЧА РАСПОЗНАВАНИЯ БЕЗ ОБУЧЕНИЯ

В этой задаче (обозначим ее через T₁) требуется некоторое множество объектов $X^0$ разбить на конечное число подмножеств (классов, таксонов, кластеров). В идеальном случае полученные классы при разбиении $X^0$ должны соответствовать разбиению множества $X$ на классы.

Задана задача T₀ (см. стр. 11). Для данной задачи информационный вектор в процессе решения задачи не участвует, хотя для задачи T₀ он известен. Для задачи T₀ известно также число классов $l$.

Опишем простейший алгоритм, известный как алгоритм **иерархической кластеризации**. Он может использоваться для решения задачи T₁.

### Шаг 0 (предварительный).
Формируем первоначальный набор классов. Для этого каждый объект из $X^0$ отождествляем с некоторым классом $X_i'$. Всего таких классов на предварительном шаге может быть сформировано по числу объектов, входящих в выборку $|X^0| = k$. Обозначим полученный набор классов через $X' = (X_1', ..., X_k')$.

Далее алгоритм реализуется как последовательность шагов 1-4.

### Шаг 1. 
Для каждого класса из $X_i' \in X'$ определяем точку $x_i$ по формуле
$$x_i = \left(\sum_{x_u \in X_i'} x_u \right) \times (|X_i'|)^{-1}$$

### Шаг 2. 
С помощью следующей функции попарного сравнения объектов из $X$
$$s: X \times X \to \mathbb{R}$$

для множества классов из $X'$ по соответствующим точкам $x_i$ находим близость между классами, выбираем ближайшие $X_s'$ и $X_t'$. Объединяем их в новый класс $X_{st}'$.

В качестве $s$ можно использовать любую метрику, включая описанные ниже метрики Евклида, Минковского или Хэмминга

### Шаг 3. 
После этого модифицируем набор классов $X'$ исключая из него $X_s'$, $X_t'$ и добавляя $X_{st}'$.

### Шаг 4. 
Если $|X'| = l$, то алгоритм заканчивает работу. В противном случае переходим к шагу 1.

### Полученные результаты.
При решении задачи T₁ мы получим набор классов $X' = (X_1', ..., X_l')$. При этом каждый объект из $X^0$ будет занесен в один из классов набора $X'$. Можно этому результату сопоставить матрицу из **кластеризационных векторов** $C(x) = (C_1(x), ..., C_l(x))$, компоненты которого могут быть определены следующим образом:

$$C_i(x) = \begin{cases}
1, \text{если } x \in X_i', \\
0, \text{иначе}.
\end{cases}$$

Далее, имея кластеризационную матрицу и матрицу, состоящую из информационных векторов, можно определить **меру несоответствия** информации для задач T₀ и T₁.

Эти задачи сравнимы, т.к. в них совпадает число классов. Для вычисления данной меры можно воспользоваться, к примеру, следующим алгоритмом.

### Шаг 0 (предварительный).
Каждому объекту $x \in X^0$ сопоставляем пару $(a_0(x), a_1(x))$, где $a_0(x), a_1(x)$ – номера классов для объекта $x$ по информационному и кластеризационному векторам соответственно. Далее составляем $l$ наборов из таких пар таким образом, чтобы в каждом из этих наборов первые компоненты пар совпадали. Обозначим эти наборы через $A_1 ..., A_l$. Для определенности будем считать, что в $A_i$ входят все пары, соответствующие классу с первым индексом равным $i$.

### Шаг 1.
Для каждого $A_i$ по второму индексу $a_1(x)$ вычисляем максимальное число вхождений числа из $L = \{1,2,...,l\}$. Обозначим полученные максимумы через $b_1, ..., b_l$, а соответствующие им номера классов через $c_1, ..., c_l$.

Введем следующие множества: $A = \{A_1 ..., A_l\}$, $B = \{b_1, ... b_l\}$, $C = \{c_1, ..., c_l\}$, $B_0 = \emptyset$, $C_0 = \emptyset$.

### Шаг 2.
Находим максимальный элемент в $B\backslash B_0$. Пусть это будет $b_u$, а соответствующий номер класса $c_u$. Если $c_u \in C_0$, то переходим на шаг 2.1. В противном случае на шаг 2.2.

### Шаг 2.1.
Для набора $A_u$ находим новый максимум $b_u$ по номерам классов, не содержащихся в $C_0$. Если максимум не может быть найден (отсутствуют среди $a_1(x)$ номера, не принадлежащие $C_0$), то меняем в векторах $b_1, ..., b_l$ и $c_1, ... c_l$ соответствующие компоненты $b_u$ и $c_u$ на 0, $A_0 \stackrel{\text{def}}{=} A_0 \cup A_u$ и возвращаемся на шаг 2. В противном случае меняем $b_u$ и $c_u$ на новые значения и возвращаемся на шаг 2.

### Шаг 2.2.
$B_0 \stackrel{\text{def}}{=} B_0 \cup b_u$, $C_0 \stackrel{\text{def}}{=} C_0 \cup c_u$, $A_0 \stackrel{\text{def}}{=} A_0 \cup A_u$. Если $|A_0| = l$ то алгоритм заканчивает работу (переходим на шаг 3). В противном случае возвращаемся на шаг 2.

### Шаг 3.
Фиксируем последовательность номеров классов в $A_0$. Пусть это будет такая последовательность $A_1', ..., A_l'$. Перенумеруем также номера классов $X^0$ через $X_1', ..., X_l'$ и соответствующие им максимумы через $b_1', ..., b_l'$. Подсчитываем **меру несоответствия** информации для задач T₀ и T₁ следующим образом:

$$\mu(T_0, T_1) = \left(\sum_{i=1}^{l} (|X_i'| - b_i')\right) \times |X^0|^{-1}$$

### Требования к программному продукту:
1. Любой язык программирования
2. Графический интерфейс **обязателен**;
3. Вывод на экран по запросу всей информации, которая описывает полученное решение. В данной задаче это разбиение $X' = (X_1', ..., X_l')$ и **мера несоответствия** $\mu(T_0, T_1)$.