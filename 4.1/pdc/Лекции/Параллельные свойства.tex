 \documentclass[12pt]{article}
 \usepackage[cp1251]{inputenc}
 \usepackage[russian]{babel}
 \usepackage{graphicx}
 \usepackage{amsfonts,amssymb,eucal,amsmath}

\textwidth 170 mm
\textheight 255 mm
\begin{document}
\voffset = -3.0 cm
\hoffset = -1.5 cm
\parindent = 35pt
\baselineskip 18pt
\sloppy
%\pagestyle{empty}


\newcommand{\msum}{\mathop{\sum}\limits}
\newcommand{\bN}{{\rm{\bf N}}}
\newcommand{\bZ}{{\rm{\bf Z}}}
\newcommand{\bQ}{{\rm{\bf Q}}}
\newcommand{\m}{\mathop{\rm mod}\nolimits M}
\newcommand{\rmod}{\mathop{\rm mod}\nolimits}
\newcommand{\nmod}[1]{\; {\mathop{\rm mod \;}\nolimits} #1}
\newcommand{\ndiv}[1]{\; {\mathop{\rm div \;}\nolimits} #1}
\newcommand{\rmin}{\mathop{\rm min}\limits}
\newcommand{\rmax}{\mathop{\rm max}\limits}
\newcommand{\rlog}{\mathop{\rm log}\nolimits}
\newcommand{\rlg}{\mathop{\rm lg}\nolimits}
\newcommand{\rln}{\mathop{\rm ln}\nolimits}
\newcommand{\Z}{{\rm {\bf Z}}}
\newcommand{\N}{{\rm {\bf N}}}
\newcommand{\R}{{\rm {\bf R}}}
\newcommand{\0}{{\rm {\bf 0}}}
\newfont{\wncyr}{wncyr10}



\large
%\normalsize

\baselineskip 16.6pt

 \centerline{\bf ПАРАЛЛЕЛЬНЫЕ СВОЙСТВА АЛГОРИТМА}

\bigskip

 Параллельные компьютеры (суперкомпьютеры) предназначены
  для быстрого решения больших задач.
 Чем мощнее компьютер, тем
   потенциально быстрее можно решить на нем задачу.

  Помимо возможностей суперкомпьютера, скорость решения зависит также
  от алгоритма; например, если 50\% операций алгоритма являются
 последовательными, то, согласно закону Амдала, сколько процессоров параллельного компьютера не
 используй, ускорение более чем в 2 раз получить не удастся.
 Поэтому надо изучать информационную структуру алгоритмов,
 уметь оценивать потенциальные возможности распараллеливания
 и создавать ресурс параллелизма.
 Кроме того, при использовании  параллельного компьютера
 существенную роль играет степень согласованности структуры
 параллельного алгоритма с архитектурой компьютера.
 Поэтому получение параллельного алгоритма
 должно вестись с учетом типа целевого
 суперкомпьютера.

 Таким образом, основными факторами,
 определяющими скорость выполнения алгоритма на параллельном компьютере,
 являются:
 \begin{itemize}
 \item
 возможности суперкомпьютера,
  \item
 ресурс параллелизма алгоритма,
 \item
 согласованность структуры параллельного алгоритма с архитектурой компьютера.
\end{itemize}

 Использование многоядерной техники
 порождает проблемы вычислительной математики,
 которые не возникают при использовании
 последовательных компьютеров:
\begin{itemize}
 \item
 получение информационной
 структуры алгоритмов,
  \item
 исследование параллельной структуры алгоритмов,
 \item
 построение параллельных алгоритмов,
 адекватных архитектуре целевого суперкомпьютера.
\end{itemize}

{\bfСпособы представления зависимостей}:

 --- аналитические: уровни зависимостей, векторы зависимостей,
        функции зависимостей (покрывающие функции),
       многогранники зависимостей;

 --- графовые: развернутый граф зависимостей (граф алгоритма),
 редуцированный граф зависимостей.

 Доказано (теорема В.В. Воеводина об информационном покрытии),
  что все зависимости алгоритмов, представленных линейным
 классом программ, можно задать функциями, линейно зависящими от
 параметров циклов и внешних переменных. Число таких функций
 не зависит от внешних переменных и для реальных линейных программ
 пропорционально числу операторов присваивания. Коэффициент
 пропорциональности не превосходит нескольких единиц.
 На меньшее число функций нельзя рассчитывать, если операторы
 связаны друг с другом.

  Граф алгоритма (развернутый граф зависимостей) -- это
 ориентированный граф, полученный следующим образом: каждая
операция порождает вершину графа, каждая
 зависимость операции $B$ от операции $A$ порождает дугу,
 идущую из вершины, соответствующей операции $A$,
 в вершину, соответствующую операции $B$.

  Приведем пример. Рассмотрим алгоритм, заданный следующим гнездом циклов:

 $
 \begin{array}{l}
 \hspace{4mm} \mbox{do} \; \ i=1,N\\
 \hspace{10mm} \mbox{do} \; \ j=1,N\\
 \hspace{16mm} a(i,j)=a(i-1,j)+a(i,j-1)\\
 \hspace{10mm} \mbox{enddo}\\
 \hspace{4mm} \mbox{enddo}
 \end{array}
 $
\setlength{\unitlength}{0.9mm}
 \begin{picture}(160,23)

\put(15,-25){\begin{picture}(50,40)

%
\multiput(12.5,12.5)(10,0){4}{\circle*{2}}
  \multiput(14,12.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,14)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,22.5)(10,0){4}{\circle*{2}}
  \multiput(14,22.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,24)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,32.5)(10,0){4}{\circle*{2}}
  \multiput(14,32.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,34)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,42.5)(10,0){4}{\circle*{2}}
  \multiput(14,42.5)(10,0){3}{\vector(1,0){7}}

\end{picture}}

\end{picture}


\medskip

\noindent
 Поставим в соответствие каждой операции $a(i,j)=a(i-1,j)+a(i,j-1)$
 алгоритма точку $(i,j)$. Зависимости между операциями изобразим стрелками.
 Получим граф алгоритма.

 Граф алгоритма представляет информационное ядро алгоритма,
 дает полную количественную
 информацию о зависимостях алгоритма.

 Приведем важное утверждение: в двух математически эквивалентных алгоритмах
 влияние ошибок округления одно и то же тогда и только тогда,
 когда графы алгоритмов изоморфны\footnote{Графы $G_1(V_1,E_1)$
 и $G_2(V_2,E_2)$ называются изоморфными, если существует такая биекция
 $f:V_1\rightarrow V_2$, что в $G_1$ есть ребро, соединяющее
 вершины $v_i$ и $v_j$, тогда и только тогда, когда в $G_2$ есть ребро между
 $f(v_i)$ и $f(v_j)$.} (с учетом отличия входных данных и операций,
 приписанных вершинам). На рисунках изображены графы алгоритмов
 вычисления левых и правых частей равенств
 $(a+b)\cdot c=a\cdot c + b\cdot c$,
 $(a+b)+c=a+(b+c)$.

{\small

 \setlength{\unitlength}{1.0 mm}
 \begin{picture}(200,30)
{

%
% EDG for процесс сдваивания
%
\put(-10,-5){\begin{picture}(70,30) {
%
% vertices
%

%  \multiput(10,30)(20,0){4}{\circle{2}}
 \put(10,30){$a$}
  \put(30,30){$b$}
   \put(60,20){$c$}

     \put(15,15){$a+b$}
      \put(33,6){$(a+b)\cdot c$}

    \multiput(20,20)(40,0){1}{\circle{2}}
      \multiput(40,10)(0,0){1}{\circle{2}}
%
%  vectors
%
  \multiput(11.0,29.0)(40,0){1}{\vector(1,-1){8}}
     \multiput(29.0,29.0)(40,0){1}{\vector(-1,-1){8}}
  \multiput(21.0,19.4)(40,0){1}{\vector(2,-1){17.8}}
     \multiput(59.0,19.4)(40,0){1}{\vector(-2,-1){17.8}}

}
\end{picture}}
%


\put(75,-5){\begin{picture}(70,30) {
%
% vertices
%

 \put(10,30){$a$}
  \put(30,30){$c$}
 \put(50,30){$b$}


     \put(15,16){$a\cdot c$}
       \put(60,16){$b\cdot c$}
      \put(31,6){$a\cdot c + b\cdot c$}

    \multiput(20,20)(40,0){2}{\circle{2}}
      \multiput(40,10)(0,0){1}{\circle{2}}
%
%  vectors
%
 \put(32.0,29.0){\vector(3,-1){26.5}}

  \multiput(11.0,29.0)(40,0){2}{\vector(1,-1){8}}
     \multiput(29.0,29.0)(40,0){1}{\vector(-1,-1){8}}
  \multiput(21.0,19.4)(40,0){1}{\vector(2,-1){17.8}}
     \multiput(59.0,19.4)(40,0){1}{\vector(-2,-1){17.8}}

}
\end{picture}}
%

}
\end{picture}

 \setlength{\unitlength}{1.0 mm}
 \begin{picture}(200,30)
{

%
% EDG for процесс сдваивания
%
\put(-10,-5){\begin{picture}(70,30) {
%
% vertices
%

%  \multiput(10,30)(20,0){4}{\circle{2}}
 \put(10,30){$a$}
  \put(30,30){$b$}
   \put(60,20){$c$}

     \put(15,15){$a+b$}
      \put(33,6){$(a+b)+c$}

    \multiput(20,20)(40,0){1}{\circle{2}}
      \multiput(40,10)(0,0){1}{\circle{2}}
%
%  vectors
%
  \multiput(11.0,29.0)(40,0){1}{\vector(1,-1){8}}
     \multiput(29.0,29.0)(40,0){1}{\vector(-1,-1){8}}
  \multiput(21.0,19.4)(40,0){1}{\vector(2,-1){17.8}}
     \multiput(59.0,19.4)(40,0){1}{\vector(-2,-1){17.8}}

}
\end{picture}}
%


\put(75,-5){\begin{picture}(70,34) {
%
% vertices
%

 \put(50,30){$b$}
  \put(69,30){$c$}
% \put(50,30){$b$}


     \put(20,20){$a$}
       \put(58,15){$b+c$}
      \put(29,6){$a+(b+c)$}

    \multiput(60,20)(40,0){1}{\circle{2}}
      \multiput(40,10)(0,0){1}{\circle{2}}
%
%  vectors
%
 %\put(32.0,29.0){\vector(3,-1){26.5}}

  \multiput(51.0,29.0)(40,0){1}{\vector(1,-1){8}}
     \multiput(69.0,29.0)(40,0){1}{\vector(-1,-1){8}}
  \multiput(21.0,19.4)(40,0){1}{\vector(2,-1){17.8}}
     \multiput(59.0,19.4)(40,0){1}{\vector(-2,-1){17.8}}

}
\end{picture}}
%

}
\end{picture}

}


\smallskip

 {\bf Параллельные множества.} Пусть операции алгоритма разбиты на множества
 таким образом, что никакая операция из одного множества непосредственно или
 опосредовано не зависит от операций из других множеств.
 Такие множества операций называются параллельными.
 Параллельные множества операций алгоритма можно выполнять независимо
 друг от друга. Ниже приведен граф алгоритма (умножение матрицы
 порядка 3 на
 вектор), в котором три параллельных множества операций.

 \setlength{\unitlength}{0.9 mm}
 \begin{picture}(70,70)
{
%\small

%
% EDG for prim2 (mv)
%
\put(-4,2){\begin{picture}(70,70) {
%
% vertices
%
  \multiput(27.5,9.5)(15,0){3}{\circle{5}}
  \multiput(27.5,9.5)(15,0){3}{\makebox(0,0){$$}}
    \multiput(27.5,27.5)(15,0){3}{\circle{5}}
    \multiput(27.5,27.5)(15,0){3}{\makebox(0,0){$$}}
  \multiput(27.5,42.5)(15,0){3}{\circle{5}}
  \multiput(27.5,42.5)(15,0){3}{\makebox(0,0){$$}}
    \multiput(27.5,57.5)(15,0){3}{\circle{5}}
    \multiput(27.5,57.5)(15,0){3}{\makebox(0,0){$$}}
%
%  vectors
%
  \multiput(27.5,12.0)(15,0){3}{\vector(0,1){12.6}}
  \multiput(27.5,30.0)(15,0){3}{\vector(0,1){9.6}}
  \multiput(27.5,45.0)(15,0){3}{\vector(0,1){9.6}}

}
\end{picture}}
%
}
\end{picture}

 Существование параллельных множеств операций алгоритма
  означает наличие естественного параллелизма.

\smallskip

 {\bf Параллельная форма алгоритма.} Пусть операции алгоритма разбиты на
 группы, упорядоченные так, что каждая операция любой группы зависит либо
 от начальных данных алгоритма, либо от результатов выполнения операций,
 находящихся в предыдущих группах. Представление алгоритма в подобном виде
 называется параллельной формой алгоритма. Каждая группа операций
 называется ярусом параллельной формы, число групп -- высотой параллельной
 формы, максимальное число операций в ярусе -- шириной параллельной формы.
 Минимальная высота параллельных форм алгоритма называется высотой
 алгоритма. При выполнении алгоритма на многопроцессорной
 вычислительной системе всегда реализуется некоторая параллельная форма.
Операции, принадлежащие одному ярусу, можно выполнять независимо
 друг от друга.

 Параллельную форму алгоритма для рассмотренного выше примера
  можно построить, отнеся к ярусу с номером
 $t$ все операции $(i,j)$, для которых $i+j-1=t$ (рис. ($a$), $N=4$).

% { \tiny
%
% (Кстати,
% $(E^{(2)}|D) = {
%%\small
% { \left(
% \begin{array}{cc} 1& 0 \\ 0& 1 \\
%\end{array} \right.
%\left| \begin{array}{cc} 1& 0 \\ 0& 1 \\
% \end{array} \right)^{\vphantom{(^(}}_{\vphantom{(}}\!\! .
% }
% }
% $
% Прибавим к первой строке вторую; получим
% $(P|B) = {
% %\small
% { \left(
% \begin{array}{cc} 1& 1 \\ 0& 1 \\
% \end{array} \right.
% \left| \begin{array}{cc} 1& 1 \\ 0& 1 \\
% \end{array} \right)^{\vphantom{(^(}}_{\vphantom{(}}\!\! .
% }}
% $
% )
%
%}

\setlength{\unitlength}{1.0mm}
 \begin{picture}(160,60)

%
% a
%
\put(5,7){\begin{picture}(60,50)

   {\footnotesize \multiput(10.5,9.0)(15,0){1}{\makebox(0,0){$(1,1)$}}}
\multiput(12.5,12.5)(10,0){4}{\circle*{2}}
  \multiput(14,12.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,14)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,22.5)(10,0){4}{\circle*{2}}
  \multiput(14,22.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,24)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,32.5)(10,0){4}{\circle*{2}}
  \multiput(14,32.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,34)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,42.5)(10,0){4}{\circle*{2}}
  \multiput(14,42.5)(10,0){3}{\vector(1,0){7}}
%
 \multiput(7.5,17.5)(30,30){2}{\line(1,-1){10}}
   \put(18.5,6){1}
   \put(48.5,36){7}
 \multiput(7.5,27.5)(20,20){2}{\line(1,-1){20}}
   \put(28.5,6){2}
   \put(48.5,26){6}
 \multiput(7.5,37.5)(10,10){2}{\line(1,-1){30}}
   \put(38.5,6){3}
   \put(48.5,16){5}
 \multiput(7.5,47.5)(30,30){1}{\line(1,-1){40}}
   \put(48.5,6){4}

{%\large
  \put(12,0){\makebox(0,0){($a$)}}
}

\end{picture}}

%
% b
%
%

\put(80,7){\begin{picture}(60,50)

\multiput(12.5,12.5)(10,0){4}{\circle*{2}}
  \multiput(14,12.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,14)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,22.5)(10,0){4}{\circle*{2}}
  \multiput(14,22.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,24)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,32.5)(10,0){4}{\circle*{2}}
  \multiput(14,32.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,34)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,42.5)(10,0){4}{\circle*{2}}
  \multiput(14,42.5)(10,0){3}{\vector(1,0){7}}
%
 \multiput(7.5,15)(30,30){2}{\line(2,-1){10}}
   \put(18.5,7){1}
%   \put(48.5,36){7}
 \multiput(7.5,20)(20,25){2}{\line(2,-1){20}}
   \put(28.5,7){2}
 \multiput(7.5,25)(10,20){2}{\line(2,-1){30}}
   \put(38.5,7){3}
 \multiput(7.5,30)(0,15){2}{\line(2,-1){40}}
   \put(48.5,7){4}
 \multiput(7.5,35)(30,30){1}{\line(2,-1){40}}
   \put(48.5,12){5}
 \multiput(7.5,40)(30,30){1}{\line(2,-1){40}}
   \put(48.5,17){6}
   \put(48.5,22){7}
   \put(48.5,27){8}
   \put(48.5,32){9}
   \put(48.5,37){10}

{%\large
  \put(12,0){\makebox(0,0){($b$)}}
}


\end{picture}}

\end{picture}

\vspace{-5mm}

\noindent
 Высота параллельной формы равна $2N-1$, ширина --- $N$. Соответствующий
 параллельный алгоритм можно записать в следующем виде:

 $
 \begin{array}{l}
 \hspace{4mm} \mbox{do} \; \ t=1,2N-1\\
 \hspace{10mm} \mbox{dopar}
 \; \ j=\rmax(1,t-N+1),\rmin(t,N)\\
  \hspace{21mm} i=t-j+1\\
  \hspace{21mm} a(i,j)=a(i-1,j)+a(i,j-1)\\
 \hspace{10mm} \mbox{enddopar}\\
 \hspace{4mm} \mbox{enddo}
 \end{array}
 $
\smallskip

Если к одному ярусу с номером $t$ отнести все операции $(i,j)$,
для которых $i+2j-2=t$ (рис. ($b$)), то высота параллельной формы
равна $3N-2$, ширина (для четных N) равна $\frac{N}{2}$.

Если известна параллельная форма алгоритма, то сам алгоритм можно
реализовать на параллельной вычислительной системе по шагам
последовательно ярус за ярусом. Если число процессоров и
соединений между ними достаточно, то алгоритм можно реализовать на
параллельной системе за число шагов, равное высоте алгоритма.

 Отметим, что если с помощью бинарных или унарных операций
 вычисляется значение некоторого выражения, существенным образом
 зависящего от $N$ переменных, то высота алгоритма, позволяющего
 вычислить это выражение, не меньше $\log_2 N$.
 \smallskip

 {\bf Параллельные последовательности
 вычислений.}
  Параллельные последовательности вычислений ---
  это упорядоченные множества операций алгоритма,
 которые могут выполняться одновременно.
 Зависимыми могут быть как операции одной,
 так и операции разных последовательностей.
 Явного указания операций, выполняемых одновременно, не требуется.
 Параллельные последовательности
 вычислений задают параллельные вычислительные
 процессы: один вычислительный процесс
 реализует одну последовательность вычислений.
 % это, по-видимому, не так Параллельные последовательности
 %вычислений могут задавать также
 % одновременно выполняемые потоки (нити, легковесные вычислительные
 %процессы); при этом один поток
 %реализует одну последовательность вычислений.

 Проиллюстрируем задание параллельных последовательностей вычислений
 с помощью рисунка.

\setlength{\unitlength}{1.0mm}
 \begin{picture}(160,40)

\put(0,-7){\begin{picture}(50,40)

%
\multiput(12.5,12.5)(10,0){4}{\circle*{2}}
  \multiput(14,12.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,14)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,22.5)(10,0){4}{\circle*{2}}
  \multiput(14,22.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,24)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,32.5)(10,0){4}{\circle*{2}}
  \multiput(14,32.5)(10,0){3}{\vector(1,0){7}}
    \multiput(12.5,34)(10,0){4}{\vector(0,1){7}}
\multiput(12.5,42.5)(10,0){4}{\circle*{2}}
  \multiput(14,42.5)(10,0){3}{\vector(1,0){7}}

  \multiput(17.5,3.5)(0,4){11}{\line(0,1){2.5}}
  \multiput(27.5,3.5)(0,4){11}{\line(0,1){2.5}}
  \multiput(37.5,3.5)(0,4){11}{\line(0,1){2.5}}

   \put(9.0,5){Pr1}
   \put(19.0,5){Pr2}
   \put(29.0,5){Pr3}
   \put(39.0,5){Pr4}

\end{picture}}

\end{picture}

\medskip

 \noindent
  Операции, приписанные точкам на рисунке, можно выполнять  параллельно,
 если одна координата точек задает номер процесса,
 другая --- порядок выполнения операций. После выполнения операции
 данные передаются процессу с большим номером.
 Этот пример иллюстрирует задание конвейерного параллелизма
 на уровне операций алгоритма (или на уровне макроопераций,
 если вершинам графа приписаны множества операций).

 Существование параллельных последовательностей вычислений
  означает наличие внутреннего параллелизма.



 {\bf Параллельные свойства алгоритма.}
 В параллельных вычислениях наряду с традиционными
 вычислительными свойствами
 алгоритма --- общее число выполняемых операций,
 влияние ошибок округления, размер необходимой памяти, локальность,
  сходимость ---
 требуется исследовать новые, параллельные свойства:
 число параллельных множеств,
 высота и ширина параллельной формы,
 число параллельных вычислительных процессов,
 число и объем коммуникационных операций, сложность коммуникационных связей.
 %{\small
 Наличие одних хороших свойств у алгоритма или программы не
 гарантирует, что хорошими будут и какие-то другие свойства.
 %}

 %\smallskip


  {\bf Параллельная структура алгоритма} -- совокупность сведений о параллельных множествах,
 параллельных формах алгоритма, параллельных процессах вычислений.

 %\smallskip


\end{document}
