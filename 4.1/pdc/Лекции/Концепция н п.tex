 \documentclass[12pt]{article}
 \usepackage[cp1251]{inputenc}
 \usepackage[russian]{babel}
 \usepackage{graphicx}
 \usepackage{amsfonts,amssymb,eucal,amsmath}

\textwidth 170 mm
\textheight 255 mm
\begin{document}
\voffset = -3.0 cm
\hoffset = -1.5 cm
\parindent = 35pt
\baselineskip 18pt
\sloppy
%\pagestyle{empty}


\newcommand{\msum}{\mathop{\sum}\limits}
\newcommand{\bN}{{\rm{\bf N}}}
\newcommand{\bZ}{{\rm{\bf Z}}}
\newcommand{\bQ}{{\rm{\bf Q}}}
\newcommand{\m}{\mathop{\rm mod}\nolimits M}
\newcommand{\rmod}{\mathop{\rm mod}\nolimits}
\newcommand{\nmod}[1]{\; {\mathop{\rm mod \;}\nolimits} #1}
\newcommand{\ndiv}[1]{\; {\mathop{\rm div \;}\nolimits} #1}
\newcommand{\rmin}{\mathop{\rm min}\limits}
\newcommand{\rmax}{\mathop{\rm max}\limits}
\newcommand{\rlog}{\mathop{\rm log}\nolimits}
\newcommand{\rlg}{\mathop{\rm lg}\nolimits}
\newcommand{\rln}{\mathop{\rm ln}\nolimits}
\newcommand{\Z}{{\rm {\bf Z}}}
\newcommand{\N}{{\rm {\bf N}}}
\newcommand{\R}{{\rm {\bf R}}}
\newcommand{\0}{{\rm {\bf 0}}}
\newfont{\wncyr}{wncyr10}



\large
%\normalsize





 \centerline{{\bf КОНЦЕПЦИЯ НЕОГРАНИЧЕННОГО ПАРАЛЛЕЛИЗМА}}

\bigskip

 Концепция неограниченного параллелизма --
 это способ понимания, конструктивный принцип
  построения параллельных алгоритмов,
 в основе которого лежит предположение, что алгоритм
 реализуется на параллельной вычислительной системе,
 не накладывающей на него никаких ограничений.
 Считается, что процессоров\footnote{Под процессором понимается одно вычислительное ядро.}
  может быть сколь угодно много, они
 работают а синхронном режиме, имеют общую память,
 любые передачи информации осуществляются мгновенно и без
 конфликтов.




 Основная цель -- получение
 алгоритмов минимальной высоты,
 так как в такой модели вычислений высота
 определяет время реализации алгоритма.

\textbf{Утверждение}.
 {\em Пусть на вычислительной системе, состоящей
 из $s$ процессоров с пиковой производительностью $\pi$,
 реализуется некоторый алгоритм. Пусть высота параллельной
 формы, соответствующей
 реализации алгоритма, равна $m$ и всего в алгоритме выполняется
 $N$ операций. Тогда максимально возможное ускорение системы
 равно $\dfrac{N}{m}$.
}


 \textbf{Доказательство.}
 Воспользуемся  формулой для выражения ускорения
 системы через загруженности процессоров:
  $R=\msum_{i=1}^s  p_i$.
 Предположим, что за время $T$ реализации алгоритма
 $i$-й процессор выполнил $N_i$ операций.
 По определению $p_i =\dfrac{N_i/\pi}{T}$.
 Если процессоров достаточно, то операции одного яруса параллельной
 формы система может выполнить за время,
 равное  или большее времени
 $\dfrac{1}{\pi}$ выполнения одной операции;
 время $T$ выполнения всех ярусов больше или равно $\dfrac{m}{\pi}$.
  Тогда\\
 \centerline{
 $R=\msum_{i=1}^s \dfrac{N_i/\pi}{T}
 =\dfrac{N}{\pi T} = \dfrac{m/\pi}{T}\cdot \dfrac{N}{m}
 \le \dfrac{N}{m}$} \\ при любом числе процессоров.
 $\hfill\Box$

 {\bf Пример 1} (процесс сдваивания).

 Рассмотрим параллельные формы двух
 алгоритмов вычисления произведения
 $a_1\cdot  a_2 \cdot ... \cdot a_N.$
 Пусть $N=8.$

 1. Обычная схема.

 \quad \quad Ярус 1: \quad $a_1\cdot a_2$

\quad \quad  Ярус 2: \quad  $(a_1 a_2)\cdot a_3$

\quad \quad  Ярус 3: \quad  $(a_1 a_2 a_3)\cdot a_4$

\quad \quad  Ярус 4: \quad  $(a_1 a_2 a_3 a_4)\cdot a_5$

\quad \quad  Ярус 5: \quad  $(a_1 a_2 a_3 a_4 a_5)\cdot a_6$

\quad \quad  Ярус 6: \quad  $(a_1 a_2 a_3 a_4 a_5 a_6)\cdot a_7$

\quad \quad  Ярус 7: \quad  $(a_1 a_2 a_3 a_4 a_5 a_6 a_7)\cdot a_8$


 Изобразим граф алгоритма:

 \setlength{\unitlength}{1.4 mm}
 \begin{picture}(100,10)
{

%
% EDG for обычная схема
%
\put(0,-5){\begin{picture}(70,10) {
%
% vertices
%
  \multiput(10,10)(10,0){7}{\circle{2}}
%
%  vectors
%
  \multiput(11.2,10.0)(10,0){6}{\vector(1,0){7.6}}

}
\end{picture}}
%
}
\end{picture}

%\smallskip
\noindent
 В общем случае высота алгоритма равна $N-1$,
 ширина алгоритма равна $1.$

  2. Процесс сдваивания.

\quad \quad  Ярус 1: \quad
 $a_1\cdot  a_2 \quad \quad  a_3\cdot  a_4 \quad \quad
   a_5\cdot  a_6  \quad \quad  a_7\cdot a_8$

\quad \quad  Ярус 2: \quad
 $(a_1 a_2)\cdot (a_3 a_4) \quad \quad (a_5 a_6)\cdot (a_7 a_8)$

\quad \quad  Ярус 3: \quad
 $(a_1 a_2 a_3 a_4)\cdot (a_5 a_6  a_7 a_8)$

 \setlength{\unitlength}{1.4 mm}
 \begin{picture}(100,30)
{

%
% EDG for процесс сдваивания
%
\put(0,-5){\begin{picture}(70,30) {
%
% vertices
%

  \multiput(10,30)(20,0){4}{\circle{2}}
    \multiput(20,20)(40,0){2}{\circle{2}}
      \multiput(40,10)(0,0){1}{\circle{2}}
%
%  vectors
%
  \multiput(11.0,29.0)(40,0){2}{\vector(1,-1){8}}
     \multiput(29.0,29.0)(40,0){2}{\vector(-1,-1){8}}
  \multiput(21.0,19.4)(40,0){1}{\vector(2,-1){17.8}}
     \multiput(59.0,19.4)(40,0){1}{\vector(-2,-1){17.8}}

}
\end{picture}}
%
}
\end{picture}

\noindent
 В общем случае высота алгоритма равна $\lceil \log_2 N \rceil,$
 ширина равна $\lceil  N/2 \rceil .$


  Отметим, что рассмотренные алгоритмы математически эквивалентны,
  но имеют разные вычислительные свойства,
  в том числе и разные параллельные свойства.


\textbf{Утверждение}.
 {\em Пусть с помощью операций, имеющих не более $p$ аргументов,
 вычисляется значение некоторого выражения, существенным образом
 зависящего от $N$ переменных. Тогда высота алгоритма, позволяющего
 вычислить это выражение, не меньше $\log_p N$.
}

 Действительно, рассмотрим параллельную форму алгоритма вычисления
 выражения. Пусть на нулевом ярусе расположены операции,
 соответствующие вводу значений входных переменных, на ярусе $T$
 расположена операция, вычисляющая конечный результат; $T$ --
 высота параллельной формы. Так как любая операция имеет
 не более $p$ аргументов, то на ярусе $T-1$ находится
 не более $p$ операций, на ярусе $T-2$ --
 не более $p^2$ операций. На нулевом ярусе находится
 не более $p^T$ операций. Так как $p^T\ge N$, то
 $T\ge \log_p N$.

 {\bf Пример 2} (умножение матрицы на вектор; перемножение матриц).

 Рассмотрим задачу умножения матрицы $A$ порядка $N$
 на $N$-мерный вектор $b:$\ \
  $c_i=\msum^N_{j=1} a_{ij}b_j.$
 На первом шаге можно вычислить $N^2$ произведений $a_{ij}b_j.$
 Далее, используя процесс сдваивания, за
 $\lceil \log_2 N \rceil$ шагов можно вычислить $N$ сумм,
 определяющих координаты вектора $c.$
 Высота алгоритма имеет порядок $\log_2 N,$
 ширина алгоритма равна $N^2.$

 Задачу перемножения двух матриц порядка $N$ можно рассматривать
 как задачу вычисления $N$ произведений одной матрицы
 на вектор. Если все эти произведения вычислять по описанному алгоритму,
  то получим алгоритм с высотой порядка $\log_2 N$ и
 шириной $N^3.$


 {\bf Пример 3} (процесс рекуррентного сдваивания;
 решение треугольной системы).

 Пусть заданы матрицы $A_{ij}$,
 $1\leqslant i\leqslant s$,  $1\leqslant j\leqslant r$,
  векторы  $b_1, ... ,b_s$ и векторы
  $x_{0}$, $x_{-1}$, $...~,$ $x_{-r+1}$ порядка $n$.
 Требуется вычислить векторы  $x_{i},$
 %\linebreak
 $1\leqslant i\leqslant s$,
  с помощью рекуррентных соотношений
 \begin{equation}
 x_{i}=A_{i1}x_{i-1}+ ... +A_{ir}x_{i-r}+b_{i},
 \label{rec}
 \end{equation}
 или, в более подробной записи,
 \begin{equation*}
 \begin{array}{l}
 x_{1}=A_{11}x_{0}+A_{12}x_{-1}+ ... +A_{1r}x_{1-r}+b_{1},\\
 x_{2}=A_{21}x_{1}+A_{22}x_{0}+ ... +A_{2r}x_{2-r}+b_{2},\\
 x_{3}=A_{31}x_{2}+A_{32}x_{1}+ ... +A_{3r}x_{3-r}+b_{3},\\
 \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots
 \ldots\ldots\ldots\ldots  \\
 x_{s}=A_{s1}x_{s-1}+A_{s2}x_{s-2}+ ... +A_{sr}x_{s-r}+b_{s}.
 \end{array}
 %\label{rec1}
 \end{equation*}
 На основе такого типа рекуррентных соотношений построены многие
 численные методы линейной алгебры, математической физики и анализа.

 Пусть, например, $r=1$, $A_{i1}=B$,
 %остальные $A_{ij}$ нулевые,
 все векторы $b_1, ... ,b_s$ равны. Получим метод простой итерации
 решения систем линейных алгебраических уравнений:\\
  \centerline{
 $x_{i}=Bx_{i-1}+b$.
 }
 Пусть теперь $s=N$, $r=i$, $n=1$, $x_0=0$,
 $A_{ij}=-a_{i\ i-j}$ ($i>j$, другие случаи при $r=i$, $x_0=0$
 не рассматриваются).
 Получим соотношения
 \begin{equation}
  \begin{array}{l}
 x_{1}=b_{1},\\
 x_{2}=-a_{21}x_{1}+b_{2},\\
 x_{3}=-a_{31}x_{1}-a_{32}x_{2}+b_{3},\\
 \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots
 \ldots \ldots \ldots \\
 x_{N}=-a_{N1}x_{1}-a_{N2}x_{2}- ... -a_{N N-1}x_{N-1}+b_{N}
 \end{array}
 \label{opodst}
 \end{equation}
 для решения системы линейных алгебраических уравнений
  \begin{equation}
\left\{
  \begin{array}{l}
 x_{1}=b_{1},\\
 a_{21}x_{1}+x_{2}=b_{2},\\
 a_{31}x_{1}+a_{32}x_{2}+x_{3}=b_{3},\\
 \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots \ldots
 \ldots \ldots \ldots \\
 a_{N1}x_{1}+a_{N2}x_{2}+ ... +a_{N N-1}x_{N-1}+x_{N}=b_{N}
 \end{array} \right.
 \label{trslae}
 \end{equation}
 с треугольной матрицей, у которой диагональные элементы равны единице.

 Используя рассмотренный алгоритм умножения матрицы на вектор,
 можно вычислить вектор $x_{i}$, задаваемый соотношением
 (\ref{rec}), примерно
  за $\log_2 n+\log_2 r = \log_2 nr$
  шагов при наличии порядка $n^2 r$ процессоров.
  Для вычисления всех $x_{i}$ получим параллельный алгоритм
   высоты $s\log_2 nr.$
 Оказывается, вычислить векторы
  $x_{i},$ $1\leqslant i\leqslant s,$ можно за меньшее
  (примерно $\log_2 s \cdot \log_2 nr$) число шагов.

 Запишем рекуррентные соотношения
 (\ref{rec}) в избыточном виде через матрицы и векторы
 высшего порядка:
\begin{equation*}
\left(
 \begin{array}{l}
 x_{i} \\ x_{i-1} \\ \ldots \\ x_{i-r+1} \\ 1 \\
 \end{array} \right)
  =
 \left(
 \begin{array}{ccccc}
  A_{i1} & \ldots & A_{i r-1} & A_{ir} & b_{i} \\
  E & \ldots & 0 & 0 & 0 \\
  \ldots & \ldots & \ldots & \ldots & \ldots \\
  0 & \ldots & E & 0 & 0 \\
 0 & \ldots & 0 & 0 & 1 \\
 \end{array} \right)
 \left(
\begin{array}{l}
 x_{i-1} \\ x_{i-2} \\ \ldots \\ x_{i-r} \\ 1 \\
 \end{array} \right),  \ r\ne 1.
%\label{mv}
\end{equation*}
 Обозначим матрицу через $Q_i$, вектор в левой части через $y_i$.
 Тогда
 $$
 y_i=Q_i y_{i-1}= \ldots = Q_i Q_{i-1} \ldots Q_1 y_0,\ \
 1\leqslant i\leqslant s .
 $$
 
 Смысл такой избыточной записи заключается в том, что все
 $y_{1}, \ldots , y_s$, а значит и все $x_{1}, \ldots , x_s$,
 можно вычислять одновременно.
 Если, например, $r=1$, $s=3$, то
 $
 Q_i=
  \left(
 \begin{array}{cc}
 A_{i 1} & b_{i} \\
 0 & 1 \\
 \end{array}
 \right),
$
$
 y_i=
  \left(
 \begin{array}{c}
  x_{i} \\
  1 \\
 \end{array}
 \right),
$ 

$
 y_1=
  \left(
 \begin{array}{cc}
 A_{1 1} & b_{1} \\
 0 & 1 \\
 \end{array}
 \right)
  \left(
 \begin{array}{c}
  x_{0} \\
  1 \\
 \end{array}
 \right),
$

$
 y_2=
  \left(
 \begin{array}{cc}
 A_{2 1} & b_{2} \\
 0 & 1 \\
 \end{array}
 \right)
   y_1
 =
 \left(
 \begin{array}{cc}
 A_{2 1} & b_{2} \\
 0 & 1 \\
 \end{array}
 \right)
  \left(
 \begin{array}{cc}
 A_{1 1} & b_{1} \\
 0 & 1 \\
 \end{array}
 \right)
  \left(
 \begin{array}{c}
  x_{0} \\
  1 \\
 \end{array}
 \right),
 $

$
 y_3=
  \left(
 \begin{array}{cc}
 A_{3 1} & b_{3} \\
 0 & 1 \\
 \end{array}
 \right)
   \left(
 \begin{array}{cc}
 A_{2 1} & b_{2} \\
 0 & 1 \\
 \end{array}
 \right)
  \left(
 \begin{array}{cc}
 A_{1 1} & b_{1} \\
 0 & 1 \\
 \end{array}
 \right)
  \left(
 \begin{array}{c}
  x_{0} \\
  1 \\
 \end{array}
 \right).
 $
\\
 Видно, что
 $y_1$, $y_2$, $y_3$, т.е.
 $\left(
 \begin{array}{c}
  x_{1} \\
  1 \\
 \end{array}
 \right),
 $
$\left(
 \begin{array}{c}
  x_{2} \\
  1 \\
 \end{array}
 \right),
 $
$\left(
 \begin{array}{c}
  x_{3} \\
  1 \\
 \end{array}
 \right),
 $
 можно вычислять одновременно.

 Матрицы $Q_i$ и векторы $y_i$ имеют порядок $nr+1$.
 Согласно алгоритму сдваивания,  любое из произведений
 $Q_i Q_{i-1} \ldots Q_1 y_0$
 можно вычислить за
 $\lceil \log_2 (s+1) \rceil$ макроопераций умножения двух матриц
 порядка $nr+1$. Все макрооперации во всех $s$ произведениях можно вычислять одновременно.
 Используя рассмотренный параллельный алгоритм для умножения двух
 матриц, получим параллельный алгоритм для
 вычислить всех векторов
  $x_{1}, \ldots , x_s$,  который имеет
  высоту порядка $\log_2 s \cdot \log_2 nr$ и
 ширину порядка  $(nr)^3 s^2$.
 Этот алгоритм получил название
  процесс рекуррентного сдваивания,

 С помощью процесса рекуррентного сдваивания
 можно решить систему линейных алгебраических уравнений
 с треугольной $N\times N$ матрицей примерно за
 $\log_2^2 N$ шагов, задействовав порядка $N^5$
 процессоров. Действительно,
 за один параллельный шаг, используя около $N^2/2$
 процессоров, можно сделать равными 1 все диагональные элементы
 матрицы, разделив их на соответствующие коэффициенты.
 Затем следует решить систему (\ref{trslae})
 с помощью соотношений (\ref{opodst});
 напомним, $n=1$, $r=i$, $s=N$.

 В случае метода простой итерации ($r=1$) $s$ итераций можно
 выполнить за
 $\log_2 s \cdot \log_2 n$  шагов на  $n^3 s^2$ процессорах.


  {\bf Пример 4} (вычисление обратной матрицы [1]).
  Пусть $A$ -- квадратная матрица порядка $N$.
  Можно вычислить $A^{-1}$ за $O(\log_2^2 N)$ шагов на $N^4$ процессорах).

 Получение алгоритмов минимальной высоты --
 задача не простая (примеры 1 и 2 -- исключение).
 На сегодняшний день достижения в рамках
 концепции неограниченного параллелизма
 представляют набор достижений в
 области численных методов.

 На практике алгоритмы небольшой высоты не нашли применения:

 -- они требуют чрезмерно большого числа процессоров,

 -- требуют очень много памяти,

 -- приводят к сложным коммуникационным связям между вычислительными
  узлами,

 -- процессоры загружены крайне слабо.

 \noindent
 Единственным исключением являются алгоритмы сдваивания для
 многократного применения ассоциативных операций, например,
 сложения и умножения чисел, матриц.

 Тем не менее, концепция неограниченного параллелизма
 очень полезна для знакомства с параллельными вычислениями,
 для лучшего понимания некоторых понятий и проблем
 параллельных вычислений.

%\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Литература

{\small

\begin{center}\textbf{Литература}\end{center}

 1.  Воеводин В. В., Воеводин Вл. В. Параллельные вычисления. --
  СПб.: БХВ-Петербург, 2002. -- 608 с.

 2. Воеводин В. В. Вычислительная математика и структура алгоритмов. --
  Москва: Изд-во МГУ, 2006. -- 112 с.\ \
  http://parallel.ru/info/parallel/voevodin/

}






\end{document}
